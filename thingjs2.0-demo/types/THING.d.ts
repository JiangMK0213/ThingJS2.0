/**
 * @property object - The object.
 * @property options - The options.
 */
declare type BaseActionData = {
  object: THING.BaseObject;
  options: any;
};

/**
 * @property position - The position.
 * @property normal - The normal.
 * @property uv - The uv.
 * @property index - The index of position.
 */
declare type MeshResult = {
  position: Number[];
  normal: Number[];
  uv: Number[];
  index: Number[];
};

/**
 * The function to call when stop action.
 */
declare type OnActionProcessorStop = () => void;

/**
 * The function to call when run action.
 * @param options - The options.
 */
declare type OnActionProcessorRun = (options: any) => Promise<any>;

/**
 * The function to call when run action.
 * @param value - The value.
 */
declare type OnActionProcessorEnable = (value: boolean) => void;

declare type ActionProcessor = {
  onStop: OnActionProcessorStop;
  onRun: OnActionProcessorRun;
  onEnable: OnActionProcessorEnable;
};

/**
 * The function to call when traverse action processor.
 */
declare type OnTraverseActionProcessorCallback = () => void;

/**
 * BaseState
The base state.
 */
declare class BaseState {}

/**
 * The function to call when get the module name.
 * @param url - The url.
 */
declare type OnGetWasmModuleCallback = (url: string) => any;

declare type LoadWasmFileOptions = {
  onGetWasmModule: OnGetWasmModuleCallback;
};

/**
 * @property url - The auth resource url.
 * @property wasmRootPath - The wasm root path.
 * @property method - The request method.
 * @property requestHeaders - The request headers.
 * @property postFields - The post field when using 'POST' method.
 * @property maxWorkerNumber - The max worker number, -1 indicates use as default.
 */
declare type LoginOptions = {
  url: string;
  wasmRootPath: string;
  method: string;
  requestHeaders: string;
  postFields: string;
  maxWorkerNumber: number;
};

/**
 * Configuration about app renderSettings.
 * @property background - The camera's background.
 * @property environment - The scene's global environmentMap.
 * @property light - The lights config(lights under app.root.children).
 * @property PostEffectInfo - The camera postEffect info.
 * @property cameraEffectInfo - The camera effect info.
 */
declare type RenderSettingsInfo = {
  background: background;
  environment: environment;
  light: lights;
  PostEffectInfo: postEffects;
  cameraEffectInfo: cameraEffects;
};

/**
 * Configuration about background
 */
declare type background = ImageTexture | CubeTexture | Number[];

/**
 * Configuration about environment
 * @property envMap - The scene's envMap.
 * @property diffuseIntensity - The envMap light Intensity
 */
declare type environment = {
  envMap: ImageTexture | CubeTexture;
  diffuseIntensity: number;
};

/**
 * When initialize component.
 */
declare type OnInitComponentCallback = () => void;

/**
 * When load resource.
 */
declare type OnLoadResourceComponentCallback = () => void;

/**
 * When unload resource.
 */
declare type OnUnloadResourceComponentCallback = () => void;

/**
 * When update component.
 * @param deltaTime - The delta time in seconds.
 */
declare type OnUpdateComponentCallback = (deltaTime: number) => void;

/**
 * Get the center position.
 * @param target - The target to save result.
 */
declare type GetCenterFunction = (target: Number[]) => Number[];

/**
 * Convert self position to world position.
 * @param position - The world position.
 * @param ignoreScale - True indicates to ignore scale.
 * @param target - The target to save result.
 */
declare type SelfToWorldFunction = (
  position: Number[],
  ignoreScale: boolean,
  target: Number[]
) => Number[];

/**
 * Convert world position to screen position.
 * @param position - The world position.
 * @param target - The target to save result.
 */
declare type WorldToScreenFunction = (
  position: Number[],
  target: Number[]
) => Number[];

/**
 * When parent change.
 * @param parent - The new parent.
 */
declare type OnParentChangeComponentCallback = (
  parent: THING.BaseObject
) => void;

/**
 * When resize component.
 * @param width - The width in pixel.
 * @param height - The height in pixel.
 */
declare type OnResizeComponentCallback = (
  width: number,
  height: number
) => void;

/**
 * When refresh component.
 */
declare type OnRefreshComponentCallback = () => void;

/**
 * When active state change.
 * @param value - The active state.
 */
declare type OnActiveChangeComponentCallback = (value: boolean) => void;

/**
 * When (body) visible change.
 * @param value - The visible state.
 */
declare type OnVisibleChangeComponentCallback = (value: boolean) => void;

/**
 * When copy component.
 * @param component - The component.
 */
declare type OnCopyComponentCallback = (component: THING.BaseComponent) => void;

/**
 * When add child object.
 * @param object - The child object.
 */
declare type OnAddChildComponentCallback = (object: THING.BaseObject) => void;

/**
 * When remove child object.
 * @param object - The child object.
 */
declare type OnRemoveChildComponentCallback = (
  object: THING.BaseObject
) => void;

/**
 * When before add component.
 * @param object - The child object.
 */
declare type OnBeforeAddComponentCallback = (object: THING.BaseObject) => void;

/**
 * When after add component.
 */
declare type OnAfterAddComponentCallback = () => void;

/**
 * When before remove component.
 */
declare type OnBeforeRemoveComponentCallback = () => void;

/**
 * When after remove component.
 */
declare type OnAfterRemoveComponentCallback = () => void;

/**
 * When import data.
 * @param param - The parameters.
 */
declare type OnImportComponentCallback = (param: any) => void;

/**
 * When export data.
 */
declare type OnExportComponentCallback = () => any;

/**
 * The function to call when traverse component by type.
 * @param component - The component.
 * @param name - The component name.
 */
declare type TraverseComponentByTypeCallback = (
  component: THING.BaseComponent,
  name: string
) => void;

/**
 * @property url - The resource URL(s).
 * @property data - The json data(s).
 */
declare type BlueprintComponentLoadArgs = {
  url: string | String[];
  data: any | object[];
};

/**
 * @property center - The center of light sphere.
 * @property radius - The radius of light sphere, 0 indicates use the radius of bounding box.
 * @property shadowRadius - The shadow's radius of light sphere, 0 indicates use the radius or radius of bounding box.
 */
declare type LightSphereInfo = {
  center: Number[];
  radius: number;
  shadowRadius: number;
};

/**
 * @property center - The center position.
 * @property halfSize - The half size.
 */
declare type BoundaryResult = {
  center: Number[];
  halfSize: Number[];
};

/**
 * Configuration about glow.
 * @property enable - True indicates enable it.
 * @property strength - The strength.
 * @property threshold - The threshold.
 * @property radius - True radius.
 */
declare type CameraGlowEffect = {
  enable: boolean;
  strength: number;
  threshold: number;
  radius: number;
};

/**
 * Configuration about inner glow.
 * @property enable - True indicates enable it.
 * @property color - The color.
 * @property strength - The strength.
 * @property stride - True stride.
 */
declare type CameraInnerGlowEffect = {
  enable: boolean;
  color: Number[];
  strength: number;
  stride: number;
};

/**
 * Configuration about tailing.
 * @property enable - True indicates enable it.
 * @property direction - The direction.
 * @property center - The center.
 */
declare type CameraTailingEffect = {
  enable: boolean;
  direction: Number[];
  center: Number[];
};

/**
 * Configuration about radial.
 * @property enable - True indicates enable it.
 * @property center - The center.
 */
declare type CameraRadialEffect = {
  enable: boolean;
  center: Number[];
};

/**
 * Configuration about ghosting.
 * @property enable - True indicates enable it.
 * @property center - The center.
 */
declare type CameraGhostingEffect = {
  enable: boolean;
  center: Number[];
};

/**
 * Configuration about line bloom.
 * @property enable - True indicates enable it.
 * @property blendRate - The blend rate.
 * @property blurSize - The blur size.
 * @property strength - The strength.
 */
declare type CameraLineBloomEffect = {
  enable: boolean;
  blendRate: number;
  blurSize: number;
  strength: number;
};

/**
 * @property object - The object.
 * @property position - The picked position.
 * @property pickedId - The picked Id.
 * @property external - The external info.
 */
declare type PickResult = {
  object: THING.BaseObject;
  position: Number[];
  pickedId: number;
  external: any;
};

/**
 * The function to call when pick object.
 * @param object - The object.
 */
declare type onPickObjectCallback = (object: THING.Object3D) => THING.Object3D;

/**
 * Temporal super sampling
 * @property enable - True indicates enable it.
 * @property size - The max frames.
 */
declare type TemporalSuperSampling = {
  enable: boolean;
  size: number;
};

/**
 * Configuration about bloom post effect
 * @property enable - True indicates enable it.
 * @property strength - The intensity.
 * @property radius - The radius.
 * @property threshold - The threshold.
 */
declare type Bloom = {
  enable: boolean;
  strength: number;
  radius: number;
  threshold: number;
};

/**
 * Configuration about screen space ambient occulusion (SSAO).
 * @property enable - True indicates enable it.
 * @property radius - The radius.
Sampling radius in work space.
Larger will produce more soft concat shadow.
But also needs higher quality or it will have more obvious artifacts
 * @property quality - Quality of SSAO. 'low'|'medium'|'high'|'ultra'.
 * @property intensity - The intensity.
 * @property temporalFilter - The temporal filter in temporal super sampling mode.
 * @property ignoreTransparent - if ignore transparent objects.
 */
declare type ScreenSpaceAmbientOcclusion = {
  enable: boolean;
  radius: number;
  quality: string;
  intensity: number;
  temporalFilter: boolean;
  ignoreTransparent: boolean;
};

/**
 * Configuration about screen space reflection.
 * @property enable - True indicates enable it.
 */
declare type ScreenSpaceReflection = {
  enable: boolean;
  maxRayDistance: number;
  pixelStride: number;
  pixelStrideZCutoff: number;
  screenEdgeFadeStart: number;
  eyeFadeStart: number;
  eyeFadeEnd: number;
  minGlossiness: number;
};

/**
 * Configuration about color correction.
 * @property enable - True indicates enable it.
 */
declare type ColorCorrection = {
  enable: boolean;
  exposure: number;
  brightness: number;
  contrast: number;
  saturation: number;
  gamma: number;
};

/**
 * Configuration about dof.
 * @property enable - True indicates enable it.
 */
declare type Dof = {
  enable: boolean;
  focalDepth: number;
  focalLength: number;
  fstop: number;
  maxblur: number;
  threshold: number;
  gain: number;
  bias: number;
  dithering: number;
};

/**
 * Configuration about vignetting.
 * @property enable - True indicates enable it.
 * @property color - The color, only for color type
 * @property offset - The offset.
 */
declare type Vignetting = {
  enable: boolean;
  color: Number[];
  offset: number;
};

/**
 * Configuration about blur edge.
 * @property enable - True indicates enable it.
 * @property offset - The offset.
 */
declare type BlurEdge = {
  enable: boolean;
  offset: number;
};

/**
 * Configuration about film effect.
 * @property enable - True indicates enable it.
 */
declare type Film = {
  enable: boolean;
  grayscale: boolean;
  noiseIntensity: number;
  scanlinesIntensity: number;
  scanlinesCount: number;
};

/**
 * Chromatic aberration.
 * @property enable - True indicates enable it.
 */
declare type ChromaticAberration = {
  enable: boolean;
  chromaFactor: number;
};

/**
 * Configuration about FXAA.
 * @property enable - True indicates enable it.
 */
declare type FXAA = {
  enable: boolean;
};

/**
 * Configuration about MSAA.
 * @property enable - True indicates enable it.
 */
declare type MSAA = {
  enable: boolean;
};

/**
 * Configuration about post effect.
 * @property enable - True indicates enable it.
 * @property bloom - The bloom effect.
 * @property screenSpaceAmbientOcclusion - The screen space ambient occlusion effect.
 * @property screenSpaceReflection - The screen space reflection effect.
 * @property colorCorrection - The color correction effect.
 * @property dof - The dof effect.
 * @property vignetting - The vignetting effect.
 * @property blurEdge - The blur edge effect.
 * @property film - The film effect.
 * @property chromaticAberration - The chromatic aberration effect.
 * @property FXAA - The FXAA effect.
 * @property MSAA - The MSAA effect.
 * @property temporalSuperSampling - The temporal super sampling effect.
 */
declare type PostEffectInfo = {
  enable: boolean;
  bloom: Bloom;
  screenSpaceAmbientOcclusion: ScreenSpaceAmbientOcclusion;
  screenSpaceReflection: ScreenSpaceReflection;
  colorCorrection: ColorCorrection;
  dof: Dof;
  vignetting: Vignetting;
  blurEdge: BlurEdge;
  film: Film;
  chromaticAberration: ChromaticAberration;
  FXAA: FXAA;
  MSAA: MSAA;
  temporalSuperSampling: TemporalSuperSampling;
};

/**
 * When start to active component(just only once) in async mode.
 * @param param - The initial parameters.
 */
declare type OnStartAsyncComponentCallback = (param: any) => Promise<any>;

/**
 * When update before render.
 * @param deltaTime - The delta time in seconds.
 */
declare type OnLateUpdateComponentCallback = (deltaTime: number) => void;

/**
 * @property visible - The visible state.
 * @property color - The color.
 * @property mode - The mode.
 */
declare type BoxHelperResult = {
  visible: boolean;
  color: Number[];
  mode: BoxHelperModeType;
};

/**
 * The level event info.
 * @property path - The level path.
 * @property origin - The original level object.
 * @property prev - The previous level object.
 * @property current - The current level object.
 * @property next - The next level object (only for leave operation).
 * @property options - The level options.
 */
declare type LevelEventInfo = {
  path: THING.BaseObject[];
  origin: THING.BaseObject;
  prev: THING.BaseObject;
  current: THING.BaseObject;
  next: THING.BaseObject;
  options: any;
};

/**
 * When leave self level in async mode.
 * @param ev - The event info.
 * @param resolve - The promise resolve callback function.
 * @param reject - The promise reject callback function.
 */
declare type OnLeaveLevelAsyncCallback = (
  ev: LevelEventInfo,
  resolve: (...params: any[]) => any,
  reject: (...params: any[]) => any
) => void;

/**
 * When leave self level.
 * @param ev - The event info.
 */
declare type OnLeaveLevelCallback = (ev: LevelEventInfo) => void;

/**
 * When enter self level in async mode.
 * @param ev - The event info.
 * @param resolve - The promise resolve callback function.
 * @param reject - The promise reject callback function.
 */
declare type OnEnterLevelAsyncCallback = (
  ev: LevelEventInfo,
  resolve: (...params: any[]) => any,
  reject: (...params: any[]) => any
) => void;

/**
 * When enter self level.
 * @param ev - The event info.
 */
declare type OnEnterLevelCallback = (ev: LevelEventInfo) => void;

/**
 * When enter self level finished.
 * @param ev - The event info.
 */
declare type OnFinishedEnterLevelCallback = (ev: LevelEventInfo) => void;

/**
 * The level configuration object.
 * @property ignoreVisible - Flag indicating whether to ignore the visibility of level setting objects.
 * @property ignoreEvent - Flag indicating whether mouse events for level objects are ignored.
 * @property ignoreStyle - Flag indicating whether to ignore the style of level setting objects.
 */
declare type LevelConfig = {
  ignoreVisible: boolean;
  ignoreEvent: boolean;
  ignoreStyle: boolean;
};

/**
 * The viewpoint.
 * @property position - the camera position
 * @property target - the camera target position
 */
declare type Viewpoint = {
  position: Number[];
  target: Number[];
};

/**
 * @property type - The event type in lowercase.
 * @property altKey - Check whether press alt key.
 * @property ctrlKey - Check whether press control key.
 * @property shiftKey - Check whether press shift key.
 * @property deltaX - The delta-x of mouse cursor in pixel.
 * @property deltaY - The delta-y of mouse cursor in pixel.
 * @property x - The x position of mouse cursor in pixel.
 * @property y - The y position of mouse cursor in pixel.
 * @property object - The picked object(could be null).
 * @property pickedPosition - The picked position in world space.
 * @property normal - The normal direction in world space.
 */
declare type MouseEventData = {
  type: string;
  altKey: boolean;
  ctrlKey: boolean;
  shiftKey: boolean;
  deltaX: number;
  deltaY: number;
  x: number;
  y: number;
  object: THING.BaseObject;
  pickedPosition: Number[];
  normal: Number[];
};

/**
 * The event type.
 */
declare const enum EventType {
  /**
   * When application quit.
   */
  AppQuit = "AppQuit",
  /**
   * When update.
   */
  Update = "Update",
  /**
   * When application focus in.
   */
  FocusIn = "FocusIn",
  /**
   * When application focus out.
   */
  FocusOut = "FocusOut",
  /**
   * When application resize.
   */
  Resize = "Resize",
  /**
   * When mouse enter object.
   */
  MouseEnter = "MouseEnter",
  /**
   * When mouse leave object.
   */
  MouseLeave = "MouseLeave",
  /**
   * When mouse move.
   */
  MouseMove = "MouseMove",
  /**
   * When mouse button up.
   */
  MouseUp = "MouseUp",
  /**
   * When mouse button down.
   */
  MouseDown = "MouseDown",
  /**
   * When mouse wheel rolling.
   */
  Wheel = "Wheel",
  /**
   * When touch end.
   */
  Click = "Click",
  /**
   * When double touch end.
   */
  DBLClick = "DBLClick",
  /**
   * When key down.
   */
  KeyDown = "KeyDown",
  /**
   * When key up.
   */
  KeyUp = "KeyUp",
  /**
   * When key is pressing.
   */
  KeyPress = "KeyPress",
  /**
   * When drop file(s) into application container.
   */
  DropFiles = "DropFiles",
  /**
   * When enter state.
   */
  EnterState = "EnterState",
  /**
   * When leave state.
   */
  LeaveState = "LeaveState",
  /**
   * When register level action for level component at the first time
   */
  RegisterLevelAction = "RegisterLevelAction",
  /**
   * Before leave object level.
   */
  BeforeLeaveLevel = "BeforeLeaveLevel",
  /**
   * Leave object level.
   */
  LeaveLevel = "LeaveLevel",
  /**
   * After leave object level.
   */
  AfterLeaveLevel = "AfterLeaveLevel",
  /**
   * Before enter object level.
   */
  BeforeEnterLevel = "BeforeEnterLevel",
  /**
   * Enter object level.
   */
  EnterLevel = "EnterLevel",
  /**
   * After enter object level.
   */
  AfterEnterLevel = "AfterEnterLevel",
  /**
   * Complete object level entering.
   */
  CompleteEnterLevel = "CompleteEnterLevel",
  /**
   * When enter(hit) object's collider(just only once before leave collider).
   */
  ColliderEnter = "ColliderEnter",
  /**
   * When leave object's collider.
   */
  ColliderLeave = "ColliderLeave",
  /**
   * When create object event.
   */
  Create = "Create",
  /**
   * When load object resource event.
   */
  Load = "Load",
  /**
   * When loading object resources.
   */
  Progress = "Progress",
  /**
   * When load object resouces failed.
   */
  Error = "Error",
  /**
   * When before destroy object event.
   */
  BeforeDestroy = "BeforeDestroy",
  /**
   * When after destroy object event.
   */
  AfterDestroy = "AfterDestroy",
  /**
   * When before add child into object.
   */
  BeforeAddChild = "BeforeAddChild",
  /**
   * When after add child into object.
   */
  AfterAddChild = "AfterAddChild",
  /**
   * When before remove child from object.
   */
  BeforeRemoveChild = "BeforeRemoveChild",
  /**
   * When after remove child from object.
   */
  AfterRemoveChild = "AfterRemoveChild",
  /**
   * When object start to fly.
   */
  StartFlying = "StartFlying",
  /**
   * When object is flying.
   */
  Flying = "Flying",
  /**
   * When object stop to fly.
   */
  StopFlying = "StopFlying",
  /**
   * When object finish to fly.
   */
  CompleteFlying = "CompleteFlying",
  /**
   * When object active attribute changed.
   */
  ActiveChange = "ActiveChange",
  /**
   * When object visible attribute changed.
   */
  VisibleChange = "VisibleChange",
  /**
   * When object stop to play animation.
   */
  StopAnimation = "StopAnimation",
  /**
   * When object start to play animation.
   */
  PlayAnimation = "PlayAnimation",
  /**
   * When object change attributes.
   */
  ChangeAttributes = "ChangeAttributes",
  /**
   * When camera enable viewport.
   */
  EnableViewport = "EnableViewport",
  /**
   * When camera is ready to start changing.
   */
  CameraChangePreStart = "CameraChangePreStart",
  /**
   * When camera starts to change.
   */
  CameraChangeStart = "CameraChangeStart",
  /**
   * When camera is changing.
   */
  CameraChange = "CameraChange",
  /**
   * When camera is ready to end change.
   */
  CameraChangePreEnd = "CameraChangePreEnd",
  /**
   * When camera ends changing.
   */
  CameraChangeEnd = "CameraChangeEnd",
  /**
   * When camera start to capture screen.
   */
  BeforeCameraCapture = "BeforeCameraCapture",
  /**
   * When camera finish to capture screen.
   */
  AfterCameraCapture = "AfterCameraCapture",
  /**
   * when before load resolvers in sceneloader
   */
  BeforeLoadResolvers = "BeforeLoadResolvers",
}

declare type Linear = {
  None: (...params: any[]) => any;
};

declare type Quadratic = {
  In: (...params: any[]) => any;
  Out: (...params: any[]) => any;
  InOut: (...params: any[]) => any;
};

declare type Cubic = {
  In: (...params: any[]) => any;
  Out: (...params: any[]) => any;
  InOut: (...params: any[]) => any;
};

declare type Quartic = {
  In: (...params: any[]) => any;
  Out: (...params: any[]) => any;
  InOut: (...params: any[]) => any;
};

declare type Quintic = {
  In: (...params: any[]) => any;
  Out: (...params: any[]) => any;
  InOut: (...params: any[]) => any;
};

declare type Sinusoidal = {
  In: (...params: any[]) => any;
  Out: (...params: any[]) => any;
  InOut: (...params: any[]) => any;
};

declare type Exponential = {
  In: (...params: any[]) => any;
  Out: (...params: any[]) => any;
  InOut: (...params: any[]) => any;
};

declare type Circular = {
  In: (...params: any[]) => any;
  Out: (...params: any[]) => any;
  InOut: (...params: any[]) => any;
};

declare type Elastic = {
  In: (...params: any[]) => any;
  Out: (...params: any[]) => any;
  InOut: (...params: any[]) => any;
};

declare type Back = {
  In: (...params: any[]) => any;
  Out: (...params: any[]) => any;
  InOut: (...params: any[]) => any;
};

declare type Bounce = {
  In: (...params: any[]) => any;
  Out: (...params: any[]) => any;
  InOut: (...params: any[]) => any;
};

/**
 * @example
 * http://sole.github.io/tween.js/examples/03_graphs.html
 */
declare type LerpType = {
  Linear: Linear;
  Quadratic: Quadratic;
  Cubic: Cubic;
  Quartic: Quartic;
  Quintic: Quintic;
  Sinusoidal: Sinusoidal;
  Exponential: Exponential;
  Circular: Circular;
  Elastic: Elastic;
  Back: Back;
  Bounce: Bounce;
};

/**
 * The loop type.
 */
declare const enum LoopType {
  /**
   * The value(s) change in repeat loop mode.
   */
  Repeat = "Repeat",
  /**
   * The value(s) change in ping-pong loop mode.
   */
  PingPong = "PingPong",
}

/**
 * The mouse button type.
 */
declare const enum MouseButtonType {
  /**
   * Invalid mouse button type.
   */
  None = "None",
  /**
   * The mouse left button type.
   */
  Left = "Left",
  /**
   * The mouse middle button type.
   */
  Middle = "Middle",
  /**
   * The mouse right button type.
   */
  Right = "Right",
}

/**
 * The space type.
 */
declare const enum SpaceType {
  /**
   * Base on self space.
   */
  Self = "Self",
  /**
   * Base on local space.
   */
  Local = "Local",
  /**
   * Base on world space.
   */
  World = "World",
}

/**
 * The code type.
 */
declare const enum CodeType {
  Escape = "Escape",
  Digit1 = "Digit1",
  Digit2 = "Digit2",
  Digit3 = "Digit3",
  Digit4 = "Digit4",
  Digit5 = "Digit5",
  Digit6 = "Digit6",
  Digit7 = "Digit7",
  Digit8 = "Digit8",
  Digit9 = "Digit9",
  Digit0 = "Digit0",
  Minus = "Minus",
  Equal = "Equal",
  Backspace = "Backspace",
  Tab = "Tab",
  KeyQ = "KeyQ",
  KeyW = "KeyW",
  KeyE = "KeyE",
  KeyR = "KeyR",
  KeyT = "KeyT",
  KeyY = "KeyY",
  KeyU = "KeyU",
  KeyI = "KeyI",
  KeyO = "KeyO",
  KeyP = "KeyP",
  BracketLeft = "BracketLeft",
  BracketRight = "BracketRight",
  Enter = "Enter",
  ControlLeft = "ControlLeft",
  KeyA = "KeyA",
  KeyS = "KeyS",
  KeyD = "KeyD",
  KeyF = "KeyF",
  KeyG = "KeyG",
  KeyH = "KeyH",
  KeyJ = "KeyJ",
  KeyK = "KeyK",
  KeyL = "KeyL",
  Semicolon = "Semicolon",
  Quote = "Quote",
  Backquote = "Backquote",
  ShiftLeft = "ShiftLeft",
  Backslash = "Backslash",
  KeyZ = "KeyZ",
  KeyX = "KeyX",
  KeyC = "KeyC",
  KeyV = "KeyV",
  KeyB = "KeyB",
  KeyN = "KeyN",
  KeyM = "KeyM",
  Comma = "Comma",
  Period = "Period",
  Slash = "Slash",
  ShiftRight = "ShiftRight",
  NumpadMultiply = "NumpadMultiply",
  AltLeft = "AltLeft",
  Space = "Space",
  CapsLock = "CapsLock",
  F1 = "F1",
  F2 = "F2",
  F3 = "F3",
  F4 = "F4",
  F5 = "F5",
  F6 = "F6",
  F7 = "F7",
  F8 = "F8",
  F9 = "F9",
  F10 = "F10",
  Pause = "Pause",
  ScrollLock = "ScrollLock",
  Numpad7 = "Numpad7",
  Numpad8 = "Numpad8",
  Numpad9 = "Numpad9",
  NumpadSubtract = "NumpadSubtract",
  Numpad4 = "Numpad4",
  Numpad5 = "Numpad5",
  Numpad6 = "Numpad6",
  NumpadAdd = "NumpadAdd",
  Numpad1 = "Numpad1",
  Numpad2 = "Numpad2",
  Numpad3 = "Numpad3",
  Numpad0 = "Numpad0",
  NumpadDecimal = "NumpadDecimal",
  F11 = "F11",
  F12 = "F12",
  F13 = "F13",
  F14 = "F14",
  F15 = "F15",
  F16 = "F16",
  F17 = "F17",
  F18 = "F18",
  F19 = "F19",
  F20 = "F20",
  F21 = "F21",
  F22 = "F22",
  F23 = "F23",
  F24 = "F24",
  NumpadComma = "NumpadComma",
  NumpadEnter = "NumpadEnter",
  ControlRight = "ControlRight",
  BrowserHome = "BrowserHome",
  NumpadDivide = "NumpadDivide",
  PrintScreen = "PrintScreen",
  AltRight = "AltRight",
  NumLock = "NumLock",
  Home = "Home",
  ArrowUp = "ArrowUp",
  PageUp = "PageUp",
  ArrowLeft = "ArrowLeft",
  ArrowRight = "ArrowRight",
  End = "End",
  ArrowDown = "ArrowDown",
  PageDown = "PageDown",
  Insert = "Insert",
  Delete = "Delete",
}

/**
 * The axis type.
 */
declare const enum AxisType {
  /**
   * X-Axis
   */
  X = "X",
  /**
   * Y-Axis
   */
  Y = "Y",
  /**
   * Z-Axis
   */
  Z = "Z",
}

/**
 * The projection type.
 */
declare const enum ProjectionType {
  /**
   * Orthographic
   */
  Orthographic = "Orthographic",
  /**
   * Perspective
   */
  Perspective = "Perspective",
}

/**
 * The view mode.
 */
declare const enum ViewMode {
  /**
   * Top
   */
  Top = "Top",
  /**
   * Bottom
   */
  Bottom = "Bottom",
  /**
   * Left
   */
  Left = "Left",
  /**
   * Right
   */
  Right = "Right",
  /**
   * Front
   */
  Front = "Front",
  /**
   * Back
   */
  Back = "Back",
}

/**
 * The align type.
 */
declare const enum AlignType {
  /**
   * Center alignment.
   */
  Center = "Center",
  /**
   * Left alignment.
   */
  Left = "Left",
  /**
   * Top alignment.
   */
  Top = "Top",
  /**
   * Top-Left alignment.
   */
  TopLeft = "TopLeft",
  /**
   * Top-Right alignment.
   */
  TopRight = "TopRight",
  /**
   * Right alignment.
   */
  Right = "Right",
  /**
   * Bottom alignment.
   */
  Bottom = "Bottom",
  /**
   * Bottom-Left alignment.
   */
  BottomLeft = "BottomLeft",
  /**
   * Bottom-Right alignment.
   */
  BottomRight = "BottomRight",
}

/**
 * The side type.
 */
declare const enum SideType {
  /**
   * Draw front side only
   */
  Front = "Front",
  /**
   * Draw back side only
   */
  Back = "Back",
  /**
   * Draw front and back sides
   */
  Double = "Double",
}

/**
 * The render type.
 */
declare const enum RenderType {
  /**
   * Sprite
   */
  Sprite = "Sprite",
  /**
   * Plane
   */
  Plane = "Plane",
}

/**
 * The pivot mode.
 */
declare const enum PivotMode {
  /**
   * Auto
   */
  Auto = "Auto",
  /**
   * Location
   */
  Location = "Location",
}

/**
 * The pick type.
 */
declare const enum PickType {
  /**
   * Raycaster
   */
  Raycaster = "Raycaster",
  /**
   * GPU
   */
  GPU = "GPU",
}

/**
 * The pick mode.
 */
declare const enum PickMode {
  /**
   * Mesh
   */
  Mesh = "Mesh",
  /**
   * BoundingBox
   */
  BoundingBox = "BoundingBox",
}

/**
 * The play state.
 */
declare const enum PlayState {
  /**
   * It's ready.
   */
  Ready = "Ready",
  /**
   * It's playing.
   */
  Playing = "Playing",
  /**
   * It had paused.
   */
  Paused = "Paused",
  /**
   * It had stopped.
   */
  Stopped = "Stopped",
  /**
   * It had finished.
   */
  Finished = "Finished",
}

/**
 * The animation direction type.
 */
declare const enum AnimationDirectionType {
  /**
   * Play in normal mode.
   */
  Normal = "Normal",
  /**
   * Play in reverse mode.
   */
  Reverse = "Reverse",
}

/**
 * The inheritance type.
 */
declare const enum InheritType {
  /**
   * The object would process action normally(process it then pass to children).
   */
  Normal = "Normal",
  /**
   * The object would process action but do not pass to children
   */
  Break = "Break",
  /**
   * The object would skip action but keep passing to children.
   */
  Jump = "Jump",
  /**
   * The object would break action and do not pass to children
   */
  Stop = "Stop",
}

/**
 * The box helper mode type.
 */
declare const enum BoxHelperModeType {
  /**
   * All
   */
  All = "All",
  /**
   * Root
   */
  Root = "Root",
  /**
   * Bodies
   */
  Bodies = "Bodies",
}

/**
 * The blending type.
 */
declare const enum BlendingType {
  /**
   * Disable blending.
   */
  No = "NoBlending",
  /**
     * Normal blending.
    color(RGB) = (sourceColor * 1) + (destinationColor * (1 - srcAlpha))
    color(A) = (sourceAlpha * 1) + (destinationAlpha * (1 - srcAlpha))
     */
  Normal = "NormalBlending",
  /**
     * Additive blending.
    color(RGBA) = (sourceColor * 1) + (destinationColor * 1).
     */
  Additive = "AdditiveBlending",
  /**
     * Subtractive blending.
    color(RGB) = destinationColor * (1 - srcAlpha)
    color(A) = destinationAlpha * 1
     */
  Subtractive = "SubtractiveBlending",
  /**
     * Multiply blending.
    color(RGB) = destinationColor * sourceColor
    color(A) = destinationAlpha * sourceAlpha
     */
  Multiply = "MultiplyBlending",
}

/**
 * The UV mode.
 */
declare const enum UVMode {
  /**
   * Fill UV as tile(s) repeatly.
   */
  Tile = "Tile",
  /**
   * Fill UV as stretch image mode.
   */
  Stretch = "Stretch",
}

/**
 * The image slot type.
 */
declare const enum ImageSlotType {
  /**
   * Map
   */
  Map = "Map",
  /**
   * EnvMap
   */
  EnvMap = "EnvMap",
  /**
   * AlphaMap
   */
  AlphaMap = "AlphaMap",
  /**
   * EmissiveMap
   */
  EmissiveMap = "EmissiveMap",
  /**
   * NormalMap
   */
  NormalMap = "NormalMap",
  /**
   * ColorMapping
   */
  ColorMapping = "ColorMapping",
  /**
   * AOMap(An Ambient Occlusion Map)
   */
  AOMap = "AOMap",
}

/**
 * The image color format type.
 */
declare const enum ImageColorFormat {
  /**
   * Red, Green, Blue(RGB) color format.
   */
  RGB = "RGB",
  /**
   * Alpha, Red, Green, Blue(RGBA) color format.
   */
  RGBA = "RGBA",
  BC7_M6_OPAQUE_ONLY = "BC7_M6_OPAQUE_ONLY",
}

/**
 * The image wrap type.
 */
declare const enum ImageWrapType {
  /**
   * Image fill in repeat mode.
   */
  Repeat = "Repeat",
  /**
   * Image use edge to repeat.
   */
  ClampToEdge = "ClampToEdge",
  /**
   * Image fill in repeat/mirror one by one mode.
   */
  MirroredRepeat = "MirroredRepeat",
}

/**
 * The image mapping type.
 */
declare const enum ImageMappingType {
  /**
   * Image texture map normally.
   */
  UV = "UV",
  /**
   * CubeReflection
   */
  CubeReflection = "CubeReflection",
  /**
   * CubeRefraction
   */
  CubeRefraction = "CubeRefraction",
  /**
   * Use the single one env map to show image, like sky box etc.
   */
  EquirectangularReflection = "EquirectangularReflection",
  /**
   * EquirectangularRefraction
   */
  EquirectangularRefraction = "EquirectangularRefraction",
}

/**
 * The image filter type.
 */
declare const enum ImageFilterType {
  /**
   * Use the value of the texture element that is nearest to the specified texture coordinates.
   */
  NearestFilter = "NearestFilter",
  /**
   * Chooses the mipmap that most closely matches the size of the pixel being textured and uses the NearestFilter.
   */
  NearestMipmapNearestFilter = "NearestMipmapNearestFilter",
  /**
   * Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the NearestFilter.
   */
  NearestMipmapLinearFilter = "NearestMipmapLinearFilter",
  /**
   * Use the weighted average of the four texture elements that are closest to the specified texture coordinates.
   */
  LinearFilter = "LinearFilter",
  /**
   * Chooses the mipmap that most closely matches the size of the pixel being textured and uses the LinearFilter.
   */
  LinearMipmapNearestFilter = "LinearMipmapNearestFilter",
  /**
   * Chooses the two mipmaps that most closely matches the size of the pixel being textured and uses the LinearFilter.
   */
  LinearMipmapLinearFilter = "LinearMipmapLinearFilter",
}

/**
 * The shadow quality type.
 */
declare const enum ShadowQualityType {
  /**
   * 512x512 shadow texture size.
   */
  Low = 512,
  /**
   * 1024x1024 shadow texture size.
   */
  Medium = 1024,
  /**
   * 2048x2048 shadow texture size.
   */
  High = 2048,
  /**
   * 4096x4096 shadow texture size.
   */
  Ultra = 4096,
}

/**
 * The action queue type.
 */
declare const enum ActionQueueType {
  /**
   * The actions of entering object level.
   */
  EnterLevel = "EnterLevel",
}

/**
 * The collider type.
 */
declare const enum ColliderType {
  /**
   * Use bounding box to check collider.
   */
  Box = "Box",
  /**
   * Use bounding sphere to check collider.
   */
  Sphere = "Sphere",
}

/**
 * The font weight.
 */
declare const enum FontWeight {
  /**
   * Normal.
   */
  Normal = "Normal",
  /**
   * Bold.
   */
  Bold = "Bold",
  /**
   * Bolder.
   */
  Bolder = "Bolder",
  /**
   * Lighter.
   */
  Lighter = "Lighter",
}

/**
 * The relationship direction type.
 */
declare const enum RelationshipDirection {
  /**
   * Out source -> target
   */
  Out = "Out",
  /**
   * In target -> source
   */
  In = "In",
  /**
   * InOut
   */
  InOut = "InOut",
  /**
   * NONE
   */
  None = "None",
}

/**
 * The filter result type.
 */
declare const enum FilterResultType {
  Pass = "Pass",
  Fail = "Fail",
  Ignore = "Ignore",
}

/**
 * The app options.
 * @property container? - The dom element to render scene.
 * @property [isEditor = false] - True indicates it's running in editor env.
 * @property background? - The background color.
 * @property envMap? - The environment map resource url.
 */
declare type AppOptions = {
  container?: HTMLElement;
  isEditor?: boolean;
  background?: number | string | Number[];
  envMap?: string;
};

/**
 * When focus change.
 * @param ev - The event info.
 */
declare type onFocusChangeCallback = (ev: FocusEvent) => void;

/**
 * The base event.
 * @property type - The case-insensitive name identifying the type of the event.
 * @property object - The object that triggered the event.
 * @property target - A reference to the object to which the event was originally dispatched.
 */
declare type BaseEvent = {
  type: string;
  object: THING.BaseObject;
  target: THING.BaseObject;
};

/**
 * The MouseEvent interface represents events that occur due to the user interacting with a pointing device (such as a mouse).
 * @property x - The X coordinate of the mouse pointer in local (screen) coordinates.
 * @property y - The Y coordinate of the mouse pointer in local (screen) coordinates.
 * @property button - The button number that was pressed when the mouse event was fired.
 * @property buttonType - The button type that was pressed when the mouse event was fired.
 * @property ctrlKey - Returns true if the ctrl key was down when the mouse event was fired.
 * @property shiftKey - Returns true if the shift key was down when the mouse event was fired.
 * @property altKey - Returns true if the alt key was down when the mouse event was fired.
 */
declare type MouseEvent = BaseEvent;

/**
 * The KeyboardEvent objects describe a user interaction with the keyboard.
 * @property keyCode - Returns a number representing the key value of the key represented by the event.
 * @property code - Returns a string representing the key value of the key represented by the event.
 * @property ctrlKey - Returns a boolean value that is true if the Ctrl key was active when the key event was generated.
 * @property shiftKey - Returns a boolean value that is true if the Shift key was active when the key event was generated.
 * @property altKey - Returns a boolean value that is true if the Alt key was active when the key event was generated.
 */
declare type KeyboardEvent = BaseEvent;

/**
 * The Event interface represents an event trigger.
 * @param ev - The case-insensitive name identifying the type of the event.
 */
declare type EventCallback = (ev: MouseEvent | KeyboardEvent) => any;

/**
 * @property rootPath - The root path.
 * @property includeSelf - True indicates export self info, default is false.
 * @property externalComponents - Check whether export external components, default is true.
 * @property lights - Check whether export lights, default is false.
 * @property camera - Check whether export camera, default is false.
 */
declare type SceneObjectExporterOptions = {
  rootPath: string;
  includeSelf: boolean;
  externalComponents: boolean;
  lights: boolean;
  camera: boolean;
};

/**
 * Create 3D object.
 * @param options - The options.
 * @param load - The load complete callback function.
 */
declare type OnPrefabBundleCreateObject = (
  options: BaseObjectInitialOptions,
  load: (...params: any[]) => any
) => THING.Object3D;

/**
 * Create prefab object.
 * @param options - The options.
 * @param load - The load complete callback function.
 */
declare type OnPrefabBundleCreatePrefabObject = (
  options: BaseObjectInitialOptions,
  load: (...params: any[]) => any
) => THING.Entity;

/**
 * The prefab bundle.
 * @property createObject - Create 3D object.
 * @property createPrefabObject - Create prefab object.
 */
declare type PrefabBundle = {
  createObject: OnPrefabBundleCreateObject;
  createPrefabObject: OnPrefabBundleCreatePrefabObject;
};

declare namespace THING {
  /**
     * BaseAction
    The base action.
     */
  class BaseAction {
    /**
         * When run action.
         * @example
         * let check = true;
        // @expect(check == true);
         * @param param - The parameters.
        class MyAction extends THING.BaseAction {
            onRun(param) {
                console.log('Run my action');
            }
        }
         */
    onRun(param: BaseActionData): void;
    /**
         * When stop action.
            class MyAction extends THING.BaseAction {
            onStop() {
                console.log('Stop my action');
            }
        }
         * @example
         * let check = true;
        // @expect(check == true);
         */
    onStop(): void;
  }
  /**
     * CameraFlyToAction
    The camera flyTo action.
     */
  class CameraFlyToAction {}
  /**
     * CreateObjectAction
    The create object action.
     */
  class CreateObjectAction {}
  /**
     * ObjectSetColorAction
    The object set color action.
     */
  class ObjectSetColorAction {}
  /**
   * The mesh builder.
   */
  class MeshBuilder {
    /**
         * Create circle.
         * @example
         * let cirecle = THING.MeshBuilder.createCircle();
        // @expect(cirecle.index.length == 192 );
         * @property options.radius - The radius.
         * @property options.segments - The number of disc segments.
         * @property options.startRad - The starting angle.
         * @param options - The options.
         */
    static createCircle(options: any): MeshResult;
    /**
     * Create cylinder.
     * @property options.radiusTop - The top radius.
     * @property options.radiusBottom - The bottom radius.
     * @property options.height - The height.
     * @property options.radialSegments - The number of divisions.
     * @property options.heightSegments - The number of height divisions.
     * @property options.openEnded - The calculate the top and bottom surfaces.
     * @property options.thetaStart - The starting angle.
     * @property options.thetaLength - The end angle.
     * @property options.poslength - The offset.
     * @param options - The options.
     */
    static createCylinder(options: any): MeshResult;
    /**
     * Create torus.
     * @property options.radius - The inner radius of ring.
     * @property options.tube - The width.
     * @property options.radialSegments - The number of tangent circle segments.
     * @property options.tubularSegments - The number of ring segments.
     * @property options.arc - The display range.
     * @param options - The options.
     */
    static createTorus(options: any): MeshResult;
    /**
     * Create capsule.
     * @property options.radius - The semicircle radius.
     * @property options.cylinderHeight - The column height.
     * @property options.widthSegments - The widthSegments.
     * @property options.heightSegments - The heightSegments.
     * @param options - The options.
     */
    static createCapsule(options: any): MeshResult;
  }
  /**
   * The action queue what can process multiple actions.
   * @example
   * let actionQueue = new THING.ActionQueue({ name: 'MyActionQueue' });
   * @param param - The initial parameters.
   */
  class ActionQueue {
    constructor(param: any);
    /**
         * Clear all groups and result.
         * @example
         * let actionQueue = new THING.ActionQueue({ name: 'MyActionQueue' });
        class ActionProcessor {
                onStop() {
                }
                onRun(options) {
                }
        };
        actionQueue.add(new ActionProcessor(), 'FirstActionProcessor', 1000);
        actionQueue.clear();
        // @expect(actionQueue.actions.length == 1);
         */
    public clear(): void;
    /**
         * Add action.
         * @example
         * // Create action processor
        class ActionProcessor {
            onStop() {
            }
        
            onRun(options) {
            }
        };
        
        actionQueue.add(new ActionProcessor(), 'FirstActionProcessor', 1000);
         * @param processor - The action processor(s).
         * @param name - The action name(only works for single processor mode).
         * @param priority - The action priority value(default is 0, higher value indicates higher priority).
         */
    public add(
      processor: ActionProcessor[] | ActionProcessor,
      name: string,
      priority: number
    ): void;
    /**
     * Get action by name.
     * @example
     * let actionProcessor = actionQueue.getByName('FirstActionProcessor');
     * @param name - The action name.
     */
    public getByName(name: string): ActionProcessor;
    /**
         * Get action by type.
         * @example
         * // ActionProcess is class type(class ActionProcessor)
        let actionProcessor = actionQueue.getByType(ActionProcessor);
         * @param type - The action type.
         */
    public getByType(type: any): ActionProcessor;
    /**
     * Remove action by name.
     * @example
     * actionQueue.removeByName('FirstActionProcessor');
     * @param name - The action name.
     */
    public removeByName(name: string): void;
    /**
         * Remove action by type.
         * @example
         * // ActionProcess is class type(class ActionProcessor)
        actionQueue.removeByType(ActionProcessor);
         * @param type - The action type.
         */
    public removeByType(type: any): void;
    /**
         * Traverse by name.
         * @example
         * actionQueue.traverseByName('PlayAction', (actionProcessor) => {
            console.log(actionProcessor);
        });
         * @param name - The action name.
         * @param callback - The callback function.
         */
    public traverseByName(
      name: string,
      callback: OnTraverseActionProcessorCallback
    ): void;
    /**
         * Traverse by type.
         * @example
         * // ActionProcess is class type(class ActionProcessor)
        actionQueue.traverseByType(ActionProcess, (actionProcessor) => {
            console.log(actionProcessor);
        });
         * @param type - The action type.
         * @param callback - The callback function.
         */
    public traverseByType(
      type: any,
      callback: OnTraverseActionProcessorCallback
    ): void;
    /**
         * Get/Set name.
         * @example
         * // Print action queue's name
        console.log(actionQueue.name);
         */
    public name: string;
    /**
         * Get actions.
         * @example
         * // Print action queue's (actions/processors)
        console.log(actionQueue.actions);
         */
    public actions: ActionProcessor[];
  }
  /**
   * Control render's FPS(frame pre second), we can limited max FPS also.
   */
  class FPSTimer {
    /**
         * Get the elapsed time(seconds) since started.
         * @example
         * // Print elapsed time(seconds) since started.
        console.log(fpsTimer.elapsedTime);
         */
    elapsedTime: number;
    /**
         * Get the delta time(seconds) from previous frame.
         * @example
         * // Print delta time(seconds) from previous frame.
        console.log(fpsTimer.deltaTime);
         */
    deltaTime: number;
    /**
         * Get the current total frame count since started.
         * @example
         * // Print current frame count since started.
        console.log(fpsTimer.currentFrameCount);
         */
    currentFrameCount: number;
    /**
     * Get/Set fixed delta time in seconds.
     */
    fixedDeltaTime: number;
    /**
         * Get/Set the max FPS number, null indicates unlimited.
         * @example
         * // Limited the max FPS to 30 fps
        fpsTimer.maxFPS = 30;
        // Unlimited the FPS
        fpsTimer.maxFPS = null;
         */
    maxFPS: number;
    /**
         * Enable/Disable fps counter.
         * @example
         * // Disable the FPS counter, if we disable then we can not get the FPS Counter info
        fpsTimer.enableFpsCounter = false;
         */
    enableFpsCounter: boolean;
    /**
         * Get the FPS Counter.
         * @example
         * // Print the current FPS counter
        console.log(fpsTimer.fpsCounter);
         */
    fpsCounter: number;
  }
  /**
     * ObjectExpression
    The object expression.
     */
  class ObjectExpression {}
  /**
     * Utils
    Useful functions.
     */
  class Utils {
    /**
     * Load code.
     * @example
     * THING.Utils.loadCode('console.log("Code load finished")');
     * @param code - The code string.
     * @param options - The options.
     * @param options.es6Mode - True indicates load code in es6 mode.
     * @param options.sourceURL - The source URL in sync mode.
     * @param options.onLoad - The load finished callback function.
     * @param options.onError - The error occurred callback function.
     */
    public static loadCode(
      code: string,
      options: {
        es6Mode: boolean;
        sourceURL: string;
        onLoad: (...params: any[]) => any;
        onError: (...params: any[]) => any;
      }
    ): void;
    /**
     * Load code in async mode.
     * @example
     * await THING.Utils.loadCodeAsync('console.log("Code load finished")');
     * @param code - The code string.
     * @param options - The options.
     * @param options.es6Mode - True indicates load code in es6 mode.
     * @param options.sourceURL - The source URL in sync mode.
     */
    public static loadCodeAsync(
      code: string,
      options: {
        es6Mode: boolean;
        sourceURL: string;
      }
    ): Promise<any>;
    /**
         * Load file(s).
         * @example
         * // Load 'my-lib.js' file by load and error callback functions
        THING.Utils.loadFile('my-lib.js', {
            onLoad: function() {
                console.log('Load finished');
            },
            onError: function() {
                console.error('Load failed');
            }
        });
         * @param resource - The file(s) resource url.
         * @param options - The options.
         * @param options.onLoad - The load finished callback function.
         * @param options.onError - The error occurred callback function.
         * @param [options.cache = true] - True indicates try to use cache.
         * @param [options.inOrder = true] - True indicates keep order to load files one by one.
         */
    public static loadFile(
      resource: string | String[],
      options: {
        onLoad: (...params: any[]) => any;
        onError: (...params: any[]) => any;
        cache?: boolean;
        inOrder?: boolean;
      }
    ): void;
    /**
         * Load file(s) in async mode.
         * @example
         * // Load 'my-lib.js' file and wait to load completed
        await THING.Utils.loadFileAsync('my-lib.js');
         * @param resource - The file(s) resource url.
         * @param options - The options.
         * @param [options.cache = true] - True indicates try to use cache.
         * @param [options.inOrder = true] - True indicates keep order to load files one by one.
         */
    public static loadFileAsync(
      resource: string | String[],
      options: {
        cache?: boolean;
        inOrder?: boolean;
      }
    ): Promise<any>;
    /**
         * Check whether it's compressed texture.
         * @example
         * let compress = THING.Utils.isCompressedTexture('image.dds');
        let uncompress = THING.Utils.isCompressedTexture('image.png');
        // @expect(compress == true && uncompress == false);
         * @param url - The compressed texture url.
         */
    public static isCompressedTexture(url: string): boolean;
    /**
         * Load image file.
         * @example
         * // Load image resource by load callback function.
        THING.Utils.loadImageFile('./assets/images/blue.png',
            function(image) {
                console.log(image);
            }
        );
         * @param url - The file URL.
         * @param onLoad - When load finished callback function.
         * @param onProgress - When loading in progression callback function.
         * @param onError - When laod error occurred callback function.
         */
    public static loadImageFile(
      url: string,
      onLoad: (...params: any[]) => any,
      onProgress: (...params: any[]) => any,
      onError: (...params: any[]) => any
    ): void;
    /**
         * Load image file in async mode.
         * @example
         * // Load image resource and wait to load finished.
        await THING.Utils.loadImageFileAsync('image.png');
         * @param url - The file URL.
         */
    public static loadImageFileAsync(url: string): Promise<any>;
    /**
         * Load binary file.
         * @example
         * let resource = document.createElement('video');;
        let check = THING.Utils.isVideoResource(resource);
        // @expect(check == true);
         * @param resource - The resource object.
         */
    public static isVideoResource(resource: any): void;
    /**
         * Load binary file.
         * @example
         * // Load 'my-file.bin' file in binary format.
        THING.Utils.loadBinaryFile('my-file.bin',
            function(data) {
                console.log('Load finished', data);
            },
            function() {
                console.error('Load failed');
            }
        );
         * @param url - The file URL.
         * @param onLoad - When load finished callback function.
         * @param onProgress - When loading in progression callback function.
         * @param onError - When laod error occurred callback function.
         * @param options - The options.
         */
    public static loadBinaryFile(
      url: string,
      onLoad: (...params: any[]) => any,
      onProgress: (...params: any[]) => any,
      onError: (...params: any[]) => any,
      options: LoadFileOptions
    ): void;
    /**
         * Load binary file in async mode.
         * @example
         * // Load 'my-file.bin' file and wait to load finished.
        await THING.Utils.loadBinaryFileAsync('my-file.bin');
         * @param url - The file URL.
         * @param options - The options.
         */
    public static loadBinaryFileAsync(
      url: string,
      options: LoadFileOptions
    ): Promise<any>;
    /**
         * Save data as file.
         * @example
         * let data = JSON.stringify('{ name: "Nice to meet you"}');
        THING.Utils.saveAsFile('test.json', data);
         * @param fileName - The file name.
         * @param data - The file data.
         */
    public static saveAsFile(
      fileName: string,
      data: string | Blob | Image
    ): boolean;
    /**
         * Save data as image.
         * @example
         * // Save 32x32 image with random pixel color
        const width = 32, height = 32;
        let pixelBuffer = [];
        for(let y = 0; y < height; y++) {
            for(let x = 0; x < width * 4; x++) {
                pixelBuffer[y * width * 4 + x] = THING.Math.randomInt(0, 255);
            }
        }
        THING.Utils.saveAsImage(width, height, new Uint8Array(pixelBuffer));
         * @param width - The image width in pixel.
         * @param height - The image height in pixel.
         * @param pixelBuffer - The image pixel buffer.
         */
    public static saveAsImage(
      width: number,
      height: number,
      pixelBuffer: Uint8Array
    ): any;
    /**
         * Load text file.
         * @example
         * // Load 'my-file.txt' file in text format.
        THING.Utils.loadTextFile('my-file.txt',
            function(data) {
                console.log('Load finished', data);
            },
            function() {
                console.error('Load failed');
            }
        );
         * @param url - The file URL.
         * @param onLoad - When load finished callback function.
         * @param onProgress - When loading in progression callback function.
         * @param onError - When laod error occurred callback function.
         * @param options - The options.
         */
    public static loadTextFile(
      url: string,
      onLoad: (...params: any[]) => any,
      onProgress: (...params: any[]) => any,
      onError: (...params: any[]) => any,
      options: LoadFileOptions
    ): void;
    /**
         * Load text file in async mode.
         * @example
         * // Load 'my-file.txt' file and wait to load finished.
        await THING.Utils.loadTextFileAsync('my-file.txt');
         * @param url - The file URL.
         * @param options - The options.
         */
    public static loadTextFileAsync(
      url: string,
      options: LoadFileOptions
    ): Promise<any>;
    /**
         * Load JSON file.
         * @example
         * // Load 'my-file.json' file in json format.
        THING.Utils.loadJSONFile('my-file.json',
            function(data) {
                console.log('Load finished', data);
            },
            function() {
                console.error('Load failed');
            }
        );
         * @param url - The file URL.
         * @param onLoad - When load finished callback function.
         * @param onProgress - When loading in progression callback function.
         * @param onError - When laod error occurred callback function.
         * @param options - The options.
         */
    public static loadJSONFile(
      url: string,
      onLoad: (...params: any[]) => any,
      onProgress: (...params: any[]) => any,
      onError: (...params: any[]) => any,
      options: LoadFileOptions
    ): void;
    /**
         * Load JSON file(s) in async mode.
         * @example
         * // Load 'my-file.json' file and wait to load finished.
        await THING.Utils.loadJSONFileAsync('my-file.json');
         * @param url - The file URL(s).
         * @param options - The options.
         */
    public static loadJSONFileAsync(
      url: string | String[],
      options: LoadFileOptions
    ): Promise<any>;
    /**
         * When run action.
         * @example
         * let type = THING.Utils.parseMouseButtonType(1);
        // @expect(type == 'Middle');
         * @param value - The button type.
         */
    public static parseMouseButtonType(value: number): void;
    /**
         * parse fly param.
         * @example
         * let ret1 = THING.Utils.parseFlyParam(100);
        let obj = new THING.BaseObject();
        let ret2 = THING.Utils.parseFlyParam(obj);
        // @expect(ret1 == 100 && ret2.target == obj);
         * @param param - The fly param.
         */
    public static parseFlyParam(param: any): any;
    /**
         * parse loop type.
         * @example
         * let ret1 = THING.Utils.parseLoopType('repeat');
        let ret2 = THING.Utils.parseLoopType('pingpong');
        let ret3 = THING.Utils.parseLoopType('temp');
        // @expect(ret1 == 'Repeat' && ret2 == 'PingPong' && ret3 == '');
         * @param name - The loop type.
         */
    public static parseLoopType(name: string): string;
    /**
         * parse lerp type
         * @example
         * let func1 = THING.Utils.parseLerpType('quadratic.in');
        let ret1 = func1(10);
        let customFunc = (amount) => {return amount + amount;};
        let func2 = THING.Utils.parseLerpType(customFunc);
        let ret2 = func2(10);
        let func3 = THING.Utils.parseLerpType('temp');
        let ret3 = func3(10);
        // @expect(ret1 == 100 && ret2 == 20 && ret3 == 10)
         * @param name - the lerp type or function.
         */
    public static parseLerpType(name: string | any): (...params: any[]) => any;
    /**
         * parse the cubetexture url
         * @example
         * let ret1 = THING.Utils.parseCubeTextureUrlsByPath();
        let ret2 = THING.Utils.parseCubeTextureUrlsByPath('./tempPath');
        let ret3 = THING.Utils.parseCubeTextureUrlsByPath('./tempPath/');
        // @expect(ret1 == null && ret2[0] == './tempPath/posx.jpg' && ret3[0] == './tempPath/posx.jpg')
         * @param path - the cubetexture path.
         */
    public static parseCubeTextureUrlsByPath(path: string): string;
    /**
         * create object by type
         * @example
         * let line = THING.Utils.createObject('PixelLine');
        let ret = line instanceof THING.PixelLine;
        // @expect(ret == true)
         * @param type - the object type.
         * @param options - the create options.
         */
    public static createObject(type: string, options: any): any;
    /**
         * check is valid texture
         * @example
         * let ret1 = THING.Utils.isValidTexture(new THING.ImageTexture());
        let ret2 = THING.Utils.isValidTexture(new THING.CubeTexture());
        let ret3 = THING.Utils.isValidTexture(new THING.RenderTexture());
        let ret4 = THING.Utils.isValidTexture(new THING.VideoTexture());
        let ret5 = THING.Utils.isValidTexture(new THING.EmptyTexture());
        let ret6 = THING.Utils.isValidTexture(new THING.BaseObject());
        // @expect(ret1 == true && ret2 == true && ret3 == true && ret4 == true && ret5 == true && ret6 == false)
         * @param value - the texture object.
         */
    public static isValidTexture(value: any): void;
    /**
     * Register class type.
     * @example
     * THING.Utils.registerClassType(MyObject, 'MyObject');
     * @param classType - The class type.
     * @param type - The type name, it would define property with 'is${type}' as getter.
     */
    public static registerClassType(classType: any, type: string): void;
    /**
     * Load WASM file.
     * @param url - The url.
     * @param options - The options.
     */
    static loadWasmFile(
      url: string,
      options: LoadWasmFileOptions
    ): Promise<any>;
    /**
         * Login.
         * @example
         * let promise1 = THING.Utils.login('http://127.0.0.1:3000/auth.json');
            let promise2 = THING.Utils.login({
                method: 'GET',
                url: 'http://127.0.0.1:3000/auth.json',
                wasmRootPath: 'js/wasm',
                postFields: 'post data'
            });
         * @param options - The url or options.
         */
    public static login(options: string | LoginOptions): Promise<any>;
    /**
         * unique the object array. process the repeat and inherit object
         * @example
         * let object1 = new THING.Object3D();
        let object2 = new THING.Object3D();
        object1.add(object2);
        let objArr = [object1, object2, object2];
        let ret = THING.Utils.uniqueObjects(objArr);
        // @expect(ret.length == 1 && ret[0] == object1)
         * @param objects - object array.
         */
    static uniqueObjects(objects: object[]): void;
    /**
         * check is gltf or glb file
         * @example
         * let ret1 = THING.Utils.isModelSceneUrl('a.gltf');
        let ret2 = THING.Utils.isModelSceneUrl('b.json');
        // @expect(ret1 == true && ret2 == false)
         * @param url - the url of the scene.
         */
    public static isModelSceneUrl(url: string): void;
    /**
         * check is gltf or glb extension
         * @example
         * let ret1 = THING.Utils.isModelSceneExtension('gltf');
        let ret2 = THING.Utils.isModelSceneExtension('json');
        // @expect(ret1 == true && ret2 == false)
         * @param ext - the file extension.
         */
    public static isModelSceneExtension(ext: string): void;
  }
  /**
   * The component of action queue by groups.
   */
  class ActionGroupComponent extends THING.BaseComponent {
    /**
         * Add group.
         * @example
         * let component = new THING.ActionGroupComponent();
        let ret = component.add('temp');
        // @expect(ret.name == 'temp')
         * @param name - The group name.
         */
    add(name: string): THING.ActionQueue;
    /**
         * Remove group.
         * @example
         * let component = new THING.ActionGroupComponent();
        let ret = component.add('temp');
        component.remove('temp');
        // @expect(component.groups.size == 0)
         * @param name - The group name.
         */
    remove(name: string): void;
    /**
         * Get group.
         * @example
         * let component = new THING.ActionGroupComponent();
        component.add('temp');
        let ret = component.get('temp');
        // @expect(ret.name == 'temp')
         * @param name - The group name.
         */
    get(name: string): any;
    /**
     * Stop group.
     * @param name - The group name.
     * @param options - The options.
     */
    stop(name: string, options: any): void;
    /**
     * Run group.
     * @param name - The group name.
     * @param options - The options.
     */
    run(name: string, options: any): Promise<any>;
    /**
         * Get the groups.
         * @example
         * let component = new THING.ActionGroupComponent();
        component.add('temp');
        let ret = component.groups.get('temp');
        // @expect(ret.name == 'temp')
         */
    groups: any;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The bundle loader interface for application.
   */
  class AppBundleComponent extends THING.BaseComponent {
    /**
     * Register bundle loader.
     * @param type - The bundle type.
     * @param loader - The loader object.
     */
    registerBundleLoader(type: string, loader: any): void;
    /**
         * Load bundle.
         * @example
         * let bundle = app.loadBundle('./bundle/scene-bundle');
            bundle.waitForComplete().then(() => {
                console.log(bundle.info.name);
                bundle.release();
            });
         * @param urls - The bundle resource url(s).
         * @param options - The options.
         */
    loadBundle(urls: string | String[], options: any): any;
    /**
         * Load bundle in async mode.
         * @example
         * let bundle = await app.loadBundleAsync('./bundle/scene-bundle');
            console.log(bundle.info.name);
            bundle.release();
         * @param urls - The bundle resource url(s).
         * @param options - The options.
         */
    loadBundleAsync(urls: string | String[], options: any): Promise<any>;
    /**
     * Unload bundle by url.
     * @example
     * THING.App.current.unloadBundle('./bundle/scene-bundle');
     * @param urls - The bundle resource url(s).
     */
    unloadBundleByUrl(urls: string | String[]): void;
    /**
     * Unload bundle
     * @example
     * THING.App.current.unloadBundle(bundle);
     * @param bundle - The bundle
     */
    unloadBundle(bundle: Bundle): void;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The application helper to show many useful information.
   */
  class AppHelperComponent extends THING.BaseComponent {
    /**
         * Set grid helper.
         * @example
         * app.helper.grid = true;
            
         * @example
         * app.helper.grid = { width: 100, height: 100, density: 10}
         */
    public grid: boolean | any;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The RenderSettings helper
   */
  class AppRenderConfigComponent extends THING.BaseComponent {
    /**
     * get/set global renderSettings.(Can only control the lights under app.root.children)
     */
    renderSettings: RenderSettingsInfo;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The resource manager to use duplicate resources, prevent to create multiple times.
   */
  class AppResourcePoolComponent extends THING.BaseComponent {
    /**
         * Load image texture from URL.
         * @example
         * let image = THING.App.current.loadImageTexture('./flower.png');
            await image.waitForComplete();
            console.log(image);
         * @param url - The resource url.
         * @param sampler - The sampler info.
         */
    loadImageTexture(
      url: string,
      sampler: LoadTextureResourceSamplerInfo
    ): THING.ImageTexture;
    /**
         * Load image texture from URL in async mode.
         * @example
         * let image = await THING.App.current.loadImageTextureAsync('./flower.png');
            console.log(image);
         * @param url - The resource url.
         * @param sampler - The sampler info.
         */
    loadImageTextureAsync(
      url: string,
      sampler: LoadTextureResourceSamplerInfo
    ): Promise<any>;
    /**
     * Load scene file
     * @param url - The load URL or options.
     * @param options - The load options.
     * @param options.url - The resource URL.
     * @param options.onComplete - The load complete callback function.
     * @param options.onProgress - The progress callback function.
     * @param options.onError - The error callback function.
     * @returns - A Promise that resolves when the loading is complete.
     */
    public load(
      url: string | any,
      options: {
        url: string;
        onComplete: (...params: any[]) => any;
        onProgress: (...params: any[]) => any;
        onError: (...params: any[]) => any;
      }
    ): Promise;
    /**
         * Load TSF (ThingJS Scene File)
         * @example
         * app.load('./myScene.json').then((ev) => {
            console.log('Load completed');
        });
         * @param url - The load URL or options.
         * @param options - The load options.
         * @param options.url - The resource URL.
         * @param options.onComplete - The load complete callback function.
         * @param options.onProgress - The progress callback function.
         * @param options.onError - The error callback function.
         * @returns - A Promise that resolves when the loading is complete.
         */
    loadTSF(
      url: string | any,
      options: {
        url: string;
        onComplete: (...params: any[]) => any;
        onProgress: (...params: any[]) => any;
        onError: (...params: any[]) => any;
      }
    ): Promise;
    /**
         * Load model scene (Currently only supports glTF)
         * @example
         * app.loadGLTF('./myScene.gltf').then(() => {
            console.log('Load completed');
        });
         * @param url - The load URL or options.
         * @param options - The load options.
         * @param options.url - The resource URL.
         * @param options.onComplete - The load complete callback function.
         * @param options.onProgress - The progress callback function.
         * @param options.onError - The error callback function.
         * @returns - A Promise that resolves when the loading is complete.
         */
    loadGLTF(
      url: string | any,
      options: {
        url: string;
        onComplete: (...params: any[]) => any;
        onProgress: (...params: any[]) => any;
        onError: (...params: any[]) => any;
      }
    ): Promise;
    /**
     * Load plugin
     * @param url - The load URL or options.
     * @param options - The load options.
     * @param options.url - The plugin URL.
     * @param options.name - The plugin name.
     * @param options.onComplete - The load complete callback function.
     * @param options.onError - The error callback function.
     */
    loadPlugin(
      url: string | any,
      options: {
        url: string;
        name: string;
        onComplete: (...params: any[]) => any;
        onError: (...params: any[]) => any;
      }
    ): Promise;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The timer controller for application.
   */
  class AppTimerComponent extends THING.BaseComponent {
    /**
         * Get the elapsed time(seconds) when started.
         * @example
         * let elapsedTime = THING.App.current.elapsedTime;
            console.log(elapsedTime);
         */
    elapsedTime: number;
    /**
         * Get the delta time(seconds) of previous frame.
         * @example
         * let deltaTime = THING.App.current.deltaTime;
            console.log(deltaTime);
         */
    deltaTime: number;
    /**
         * Get the current total frame count after started.
         * @example
         * let currentFrameCount = THING.App.current.currentFrameCount;
            console.log(currentFrameCount);
         */
    currentFrameCount: number;
    /**
         * Get/Set the max FPS number, null indicates unlimited.
         * @example
         * // Limit max render FPS to 1
            THING.App.current.maxFPS = 1;
            // Unlimit max render FPS
            THING.App.current.maxFPS = null;
         */
    maxFPS: number;
    /**
         * Get the FPS Counter.
         * @example
         * let fpsCounter = THING.App.current.fpsCounter;
            console.log(fpsCounter);
         */
    fpsCounter: number;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The base component of all components, each component should inherit from it.
   */
  class BaseComponent {
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The base component group to manage components, you should inherit from it when you want to manage multiple components.
   */
  class BaseComponentGroup {
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base line segments helper to show points, you can inherit from it when you need to show drawing points.
   */
  class BaseLineSegmentsHelperComponent extends THING.HelperComponent {
    /**
     * Show/Hide lines.
     */
    visible: boolean;
    /**
     * Get points of line(s).
     */
    points: Number[][];
    /**
     * Get colors of line(s).
     */
    colors: Number[][];
    /**
         * Get bounding box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.boundingBox;
        // @expect(bounding.mode == 'All')
         */
    public boundingBox: BoxHelperResult;
    /**
         * Get oriented box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.orientedBox;
        // @expect(bounding.mode == 'All')
         */
    public orientedBox: BoxHelperResult;
    /**
         * Show/Hide axes helper.
         * @example
         * let box = new THING.Box();
            box.helper.axes = true;
         box.waitForComplete().then(()=>{
            let ret = box.helper.axes;
           // @expect(ret == true);
         })
         */
    public axes: boolean;
    /**
         * Get/Set axes helper length.
         * @example
         * let box = new THING.Box();
            box.helper.axesLength = 10;
            // @expect(box.helper.axesLength == 10);
         */
    public axesLength: number;
    /**
         * Get the light(s)'s config.
         * @example
         * let box = new THING.Box();
            let count = box.helper.lights.length;
            // @expect(count == 0);
         */
    public lights: object[];
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * To load blueprint resource(s) and run them.
   */
  class BlueprintComponent extends THING.BaseComponent {
    /**
         * Load from URL or data.
         * @example
         * object.blueprint.load({ url: './blueprints/myBP.json' });
        object.blueprint.run();
         * @param options - The options.
         */
    public load(options: BlueprintComponentLoadArgs): THING.BlueprintComponent;
    /**
     * Run all blueprints.
     */
    public run(): void;
    /**
     * Stop all blueprints.
     */
    public stop(): void;
    /**
     * Set variable by name.
     * @param name - The variable name.
     * @param value - The variable value.
     */
    public setVar(name: string, value: any): void;
    /**
     * Set variables.
     * @param value - The variables.
     */
    public setVars(value: any): void;
    /**
     * Register event.
     * @param type - The event type.
     * @param callback - The callback function.
     */
    public addEventListener(
      type: string,
      callback: (...params: any[]) => any
    ): void;
    /**
     * Unregister event.
     * @param type - The event type.
     * @param callback - The callback function.
     */
    public removeEventListener(
      type: string,
      callback: (...params: any[]) => any
    ): void;
    /**
     * Trigger event.
     * @param type - The event type.
     * @param event - The event info.
     */
    public triggerEvent(type: string, event: any): void;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The bounding box(AABB, OBB) of object.
   */
  class BoundingComponent extends THING.BaseComponent {
    /**
         * Get/Set the bounding box inherit type.
         * @example
         * let component = new THING.BoundingComponent();;
        component.inheritType = InheritType.Normal
        // @expect(component.inheritType == InheritType.Normal)
         */
    inheritType: InheritType;
    /**
     * Get/Set the size of the picked bounding box (set null to clear).
     */
    pickedSize: Number[];
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The bounding of camera, it can work with light shadow effect system.
   */
  class CameraBoundingComponent extends THING.BoundingComponent {
    /**
         * Get/Set the bounding box inherit type.
         * @example
         * let component = new THING.BoundingComponent();;
        component.inheritType = InheritType.Normal
        // @expect(component.inheritType == InheritType.Normal)
         */
    inheritType: InheritType;
    /**
     * Get/Set the size of the picked bounding box (set null to clear).
     */
    pickedSize: Number[];
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The camera controller.
   */
  class CameraControlComponent extends THING.BaseComponent {
    /**
         * Pan in screen by pixel.
         * @example
         * // Move camera with bottom direction
            app.camera.pan(0, -50);
         * @param deltaX - The delta X in pixel.
         * @param deltaY - The delta Y in pixel.
         * @param [duration = 500] - The time in milliseconds.
         */
    public pan(deltaX: number, deltaY: number, duration?: number): void;
    /**
     * Move forward/backward.
     * @param distance - The distance (+: forward, -: backward).
     * @param param - The options.
     * @param [param.duration = 500] - The time in milliseconds.
     * @param [param.updateTarget = true] - True indicates update target's position.
     */
    zoom(
      distance: number,
      param: {
        duration?: number;
        updateTarget?: boolean;
      }
    ): void;
    /**
     * Stop current control.
     */
    stop(): void;
    /**
         * Check whether is changing or not.
         * @example
         * let camera = THING.App.current.camera;
        camera.pan(0, -50);
        // @expect(camera.isChanging == true)
         */
    public isChanging: boolean;
    /**
         * Enable/Disable control.
         * @example
         * let camera = THING.App.current.camera;
        camera.enable = false;
        // @expect(camera.enable == false)
         */
    public enable: boolean;
    /**
         * Enable/Disable auto move target forward.
         * @example
         * let camera = THING.App.current.camera;
        camera.enableAutoMoveTargetForward = false;
        // @expect(camera.enableAutoMoveTargetForward == false)
         */
    public enableAutoMoveTargetForward: boolean;
    /**
         * Enable/Disable adjust target position.
         * @example
         * let camera = THING.App.current.camera;
        camera.enableAdjustTargetPosition = false;
        // @expect(camera.enableAdjustTargetPosition == false)
         */
    public enableAdjustTargetPosition: boolean;
    /**
         * Enable/Disable adjust near.
         * @example
         * let camera = THING.App.current.camera;
        camera.enableAdjustNear = false;
        // @expect(camera.enableAdjustNear == false)
         */
    public enableAdjustNear: boolean;
    /**
         * Enable/Disable adjust pan speed.
         * @example
         * let camera = THING.App.current.camera;
        camera.enableAdjustPanSpeed = false;
        // @expect(camera.enableAdjustPanSpeed == false);
         */
    public enableAdjustPanSpeed: boolean;
    /**
         * Enable/Disable zoom to mouse cursor on wheel.
         * @example
         * let camera = THING.App.current.camera;
        camera.enableZoomToMouseCursorOnWheel = false;
        // @expect(camera.enableZoomToMouseCursorOnWheel == false);
         */
    public enableZoomToMouseCursorOnWheel: boolean;
    /**
         * Enable/Disable pick when changing.
         * @example
         * let camera = THING.App.current.camera;
        camera.enablePickWhenChanging = false;
        // @expect(camera.enablePickWhenChanging == false);
         */
    public enablePickWhenChanging: boolean;
    /**
         * Enable/Disable damping.
         * @example
         * let camera = THING.App.current.camera;
        camera.enableDamping = false;
        // @expect(camera.enableDamping == false);
         */
    public enableDamping: boolean;
    /**
         * Enable/Disable rotate.
         * @example
         * let camera = THING.App.current.camera;
        camera.enableRotate = false;
        // @expect(camera.enableRotate == false);
         */
    public enableRotate: boolean;
    /**
         * Enable/Disable pan.
         * @example
         * let camera = THING.App.current.camera;
        camera.enablePan = false;
        // @expect(camera.enablePan == false);
         */
    public enablePan: boolean;
    /**
         * Enable/Disable zoom.
         * @example
         * let camera = THING.App.current.camera;
        camera.enableZoom = false;
        // @expect(camera.enableZoom == false);
         */
    public enableZoom: boolean;
    /**
         * Enable/Disable map control.
         * @example
         * let camera = THING.App.current.camera;
        camera.enableMapControl = false;
        // @expect(camera.enableMapControl == false);
         */
    public enableMapControl: boolean;
    /**
         * Get/Set damping factor.
         * @example
         * let camera = THING.App.current.camera;
        camera.dampingFactor = 10;
        // @expect(camera.dampingFactor == 10);
         */
    public dampingFactor: number;
    /**
         * Get/Set zoom speed.
         * @example
         * let camera = THING.App.current.camera;
        camera.zoomSpeed = 10;
        // @expect(camera.zoomSpeed == 10);
         */
    public zoomSpeed: number;
    /**
         * Get/Set rotate speed.
         * @example
         * let camera = THING.App.current.camera;
        camera.rotateSpeed = 10;
        // @expect(camera.rotateSpeed == 10);
         */
    public rotateSpeed: number;
    /**
         * Get/Set pan speed.
         * @example
         * let camera = THING.App.current.camera;
        camera.panSpeed = 10;
        // @expect(camera.panSpeed == 10);
         */
    public panSpeed: number;
    /**
         * Get/Set key pan speed.
         * @example
         * let camera = THING.App.current.camera;
        camera.keyPanSpeed = 10;
        // @expect(camera.keyPanSpeed == 10);
         */
    public keyPanSpeed: number;
    /**
         * Get/Set the factor of zoom to mouse cursor on wheel.
         * @example
         * let camera = THING.App.current.camera;
        camera.zoomToMouseCursorOnWheelSpeed = 10;
        // @expect(camera.zoomToMouseCursorOnWheelSpeed == 10);
         */
    public zoomToMouseCursorOnWheelSpeed: number;
    /**
         * Set/Get distance limited range[min, max], null indicates it's unlimited.
         * @example
         * let camera = THING.App.current.camera;
        camera.distanceLimited = [10,1000];
        // @expect(camera.distanceLimited[0] == 10 && camera.distanceLimited[1] == 1000);
         */
    public distanceLimited: (Number | null)[];
    /**
         * Set/Get vert angle limited range[min, max], default is [0, 180].
         * @example
         * let camera = THING.App.current.camera;
        camera.vertAngleLimit = [10,100];
        // @expect(camera.vertAngleLimit[0] == 10 && camera.vertAngleLimit[1] == 100);
         */
    public vertAngleLimit: Number[];
    /**
         * Set/Get horz angle limited range[min, max], default is [0, 180].
         * @example
         * let camera = THING.App.current.camera;
        camera.horzAngleLimit = [10,100];
        // @expect(camera.horzAngleLimit[0] == 10 && camera.horzAngleLimit[1] == 100);
         */
    public horzAngleLimit: Number[];
    /**
         * Get/Set boundary to limit target position(null indicates clear it).
         * @example
         * let camera = THING.App.current.camera;
        let center = [10,10,10];
        let halfSize = [20,20,20];
        let boundary = {center, halfSize};
        camera.boundary = boundary;
        // @expect(camera.boundary.center[0] == 10 && camera.boundary.halfSize[0] == 20);
         */
    public boundary: BoundaryResult;
    /**
         * Get/Set up direction.
         * @example
         * let camera = THING.App.current.camera;
        camera.upDirection = [10,10,10];
        // @expect(camera.upDirection[0] == 10 && camera.upDirection[1] == 10 && camera.upDirection[2] == 10);
         */
    public upDirection: Number[];
    /**
         * Get/Set target of the world space.
         * @example
         * let camera = THING.App.current.camera;
        camera.target = [10,10,10];
        // @expect(camera.target[0] == 10 && camera.target[1] == 10 && camera.target[2] == 10);
         */
    public target: Number[];
    /**
     * Get the distance from position to target.
     */
    distance: number;
    /**
         * Get/Set space panning of the screen.
        True indicates pan action will base on screen, otherwise indicates will base on camera's Y axis direction.
        Default value is true.
         * @example
         * let camera = THING.App.current.camera;
        camera.screenSpacePanning = false;
        // @expect(camera.screenSpacePanning == false);
         */
    public screenSpacePanning: boolean;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The controller to manage event dispatch.
   */
  class CameraControlEventDispatcherComponent extends THING.BaseComponent {
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The rendering effect by camera, some object post effect(s) can be changed here.
   */
  class CameraEffectComponent extends THING.BaseComponent {
    /**
     * Enable/Disable.
     */
    enable: boolean;
    /**
     * Get the glow.
     */
    glow: CameraGlowEffect;
    /**
     * Get the inner glow.
     */
    innerGlow: CameraInnerGlowEffect;
    /**
     * Get the tailing.
     */
    tailing: CameraTailingEffect;
    /**
     * Get the radial.
     */
    radial: CameraRadialEffect;
    /**
     * Get the ghosting.
     */
    ghosting: CameraGhostingEffect;
    /**
     * Get the lineBloom.
     */
    lineBloom: CameraLineBloomEffect;
    /**
     * Get/Set config.
     */
    config: any;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The fog effect by camera.
   */
  class CameraFogComponent extends THING.BaseComponent {
    /**
     * Enable/Disable fog.
     */
    enable: boolean;
    /**
     * Get/Set the near.
     */
    near: number;
    /**
     * Get/Set the far.
     */
    far: number;
    /**
     * Get/Set the density.
     */
    density: number;
    /**
     * Get/Set the color.
     */
    color: number | string | String[];
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The camera view helper, can show frustum of camera.
   */
  class CameraHelperComponent extends THING.BaseLineSegmentsHelperComponent {
    /**
     * Show/Hide picker to check object picking.
     * @param value - True indicates show it, otherwise hide it.
     */
    showPicker(value?: boolean): void;
    /**
     * Show/Hide target node.
     * @param value - True indicates show it, otherwise hide it.
     */
    showTarget(value?: boolean): void;
    /**
     * Show/Hide helper.
     */
    visible: boolean;
    /**
     * Get points of line(s).
     */
    points: Number[][];
    /**
     * Get colors of line(s).
     */
    colors: Number[][];
    /**
         * Get bounding box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.boundingBox;
        // @expect(bounding.mode == 'All')
         */
    public boundingBox: BoxHelperResult;
    /**
         * Get oriented box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.orientedBox;
        // @expect(bounding.mode == 'All')
         */
    public orientedBox: BoxHelperResult;
    /**
         * Show/Hide axes helper.
         * @example
         * let box = new THING.Box();
            box.helper.axes = true;
         box.waitForComplete().then(()=>{
            let ret = box.helper.axes;
           // @expect(ret == true);
         })
         */
    public axes: boolean;
    /**
         * Get/Set axes helper length.
         * @example
         * let box = new THING.Box();
            box.helper.axesLength = 10;
            // @expect(box.helper.axesLength == 10);
         */
    public axesLength: number;
    /**
         * Get the light(s)'s config.
         * @example
         * let box = new THING.Box();
            let count = box.helper.lights.length;
            // @expect(count == 0);
         */
    public lights: object[];
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The interpolation control of camera, you can change position, target or up-axis direction of camera in that way.
   */
  class CameraLerpComponent extends THING.LerpComponent {
    /**
     * Start lerp.
     * @param param - The parameters.
     * @param name - The lerp name, if user want to stop it later then need to provide it.
     */
    public to(param: LerpArgs, name: string): void;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The picker by camera, user can pick object(s) from it.
   */
  class CameraPickerComponent extends THING.BaseComponent {
    /**
     * Check intersection between object and region.
     * @param region - The [left, top, width, height] region in screen.
     * @param object - The object.
     */
    intersectObjectInRegion(region: Number[], object: THING.Object3D): boolean;
    /**
     * Pick node.
     * @param x - The x coordinate in screen.
     * @param y - The y coordinate in screen.
     * @param root? - The root object to pick.
     */
    pick(x: number, y: number, root?: THING.BaseObject): PickResult;
    /**
     * Pick from cross planes.
     * @param x - The x coordinate in screen.
     * @param y - The y coordinate in screen.
     * @param isVertical - Whether vertical and horizontal planes will always be vertical.
     */
    pickFromCrossPlanes(x: number, y: number, isVertical?: boolean): PickResult;
    /**
     * Calculate the points where the plane intersects.
     * @param x - The x coordinate in screen.
     * @param y - The y coordinate in screen.
     * @param normal - The plane normal. (default [0,1,0])
     * @param constant - Distance of plane. (default 0)
     */
    intersectPlane(
      x: number,
      y: number,
      normal: Number[],
      constant: number
    ): Number[];
    /**
     * Get/Set pick type.
     */
    pickType: PickType;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The rendering effect by camera, some screen post effect(s) can be changed here.
   */
  class CameraPostEffectComponent extends THING.BaseComponent {
    /**
         * Enable/Disable effect.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.enable = false;
        // @expect(app.camera.postEffect.enable == false)
         */
    public enable: boolean;
    /**
         * Get temporal super sampling.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.temporalSuperSampling.enable = true;
        // @expect(app.camera.postEffect.temporalSuperSampling.enable == true)
         */
    public temporalSuperSampling: TemporalSuperSampling;
    /**
         * Get bloom.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.bloom.enable = true;
        // @expect(app.camera.postEffect.bloom.enable == true)
         */
    public bloom: Bloom;
    /**
         * Get screen space ambient occlusion.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.screenSpaceAmbientOcclusion.enable = true;
        // @expect(app.camera.postEffect.screenSpaceAmbientOcclusion.enable == true)
         */
    public screenSpaceAmbientOcclusion: ScreenSpaceAmbientOcclusion;
    /**
         * Get screen space reflection.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.screenSpaceReflection.enable = true;
        // @expect(app.camera.postEffect.screenSpaceReflection.enable == true)
         */
    public screenSpaceReflection: ScreenSpaceReflection;
    /**
         * Get color correction.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.colorCorrection.enable = true;
        // @expect(app.camera.postEffect.colorCorrection.enable == true)
         */
    public colorCorrection: ColorCorrection;
    /**
         * Get dof.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.dof.enable = true;
        // @expect(app.camera.postEffect.dof.enable == true)
         */
    public dof: Dof;
    /**
         * Get vignetting.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.vignetting.enable = true;
        // @expect(app.camera.postEffect.vignetting.enable == true)
         */
    public vignetting: Vignetting;
    /**
         * Get blur edge.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.blurEdge.enable = true;
        // @expect(app.camera.postEffect.blurEdge.enable == true)
         */
    public blurEdge: BlurEdge;
    /**
         * Get film.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.film.enable = true;
        // @expect(app.camera.postEffect.film.enable == true)
         */
    public film: Film;
    /**
         * Get chromatic aberration.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.chromaticAberration.enable = true;
        // @expect(app.camera.postEffect.chromaticAberration.enable == true)
         */
    public chromaticAberration: ChromaticAberration;
    /**
         * Get FXAA.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.FXAA.enable = true;
        // @expect(app.camera.postEffect.FXAA.enable == true)
         */
    public FXAA: FXAA;
    /**
         * Get MSAA.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config.MSAA.enable = false;
        // @expect(app.camera.postEffect.MSAA.enable == false)
         */
    public MSAA: MSAA;
    /**
         * Get/Set config.
         * @example
         * let app = THING.App.current
        app.camera.postEffect.config = {
          FXAA: {enable: true}
        };
        // @expect(app.camera.postEffect.config.FXAA.enable == true)
         */
    public config: PostEffectInfo;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The resource(s) controller of camera, like setting background resource etc.
   */
  class CameraResourceControllerComponent extends THING.BaseComponent {
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * To override some interfaces when transform changed of camera.
   */
  class CameraTransformComponent extends THING.TransformComponent {
    /**
         * Get/Set the distance of keep size mode.
         * @example
         * let component = new THING.TransformComponent();
        component.keepSizeDistance = 10;
        // @expect(component.keepSizeDistance == 10);
         */
    public keepSizeDistance: number;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The collider of object(s) what can listen on collider events to process hit logic code.
   */
  class ColliderComponent extends THING.BaseComponent {
    /**
     * Add event listener.
     * @param type - The event type.
     * @param listener - The event callback function.
     */
    addEventListener(type: string, listener: (...params: any[]) => any): void;
    /**
     * Remove event listener.
     * @param type - The event type.
     * @param listener - The event callback function.
     */
    removeEventListener(
      type: string,
      listener: (...params: any[]) => any
    ): void;
    /**
     * Enable/Disable.
     */
    enable: boolean;
    /**
     * Get/Set the mode.
     */
    mode: ColliderType;
    /**
     * Get/Set the radius.
     */
    radius: number;
    /**
     * Get/Set the offset.
     */
    offset: Number[];
    /**
     * Get/Set the half size.
     */
    halfSize: Number[];
    /**
     * Get/Set the visible.
     */
    visible: boolean;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
     * The component that extends some useful interfaces.
    The interface work flow:
    1. onAwake -> onStart/onStartAsync
    2. onUpdate -> onLateUpdate
     * @example
     * class MyRotator extends THING.Component {
     onAwake(param) {
      this.speed = param['speed'];
     }
    
     onStart() {
      this.object.style.color = "0xFF0000";
     }
    
     onUpdate(deltaTime) {
      this.object.rotateY(this.speed * deltaTime);
     }
    }
    
    let box = new THING.Box();
    box.addComponent(MyRotator, 'rotator');
    box.rotator.speed = 100;
     */
  class Component extends THING.BaseComponent {
    /**
     * When start to active component(just only once) in async mode and wait for finish, it's after onAwake() interface.
     */
    onStartAsync: OnStartAsyncComponentCallback;
    /**
     * When update before render.
     */
    OnLateUpdate: OnLateUpdateComponentCallback;
    /**
     * When add component(just only once).
     * @param args - The constructor arguments.
     */
    onAwake(args: any): void;
    /**
     * When start to active component(just only once), it's after onAwake() interface.
     * @param args - The constructor arguments.
     */
    onStart(args: any): void;
    /**
     * When remove component.
     */
    onDestroy(): void;
    /**
     * When active it.
     */
    onEnable(): void;
    /**
     * When deactivate it.
     */
    onDisable(): void;
    /**
     * Import data
     * @param param - The import data.
     */
    onImport(param: any): void;
    /**
     * Export data
     */
    onExport(): any;
    /**
     * Get the starting promise.
     */
    startingPromise: Promise<any>;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * Show/Hide the directional light position and direction.
   */
  class DirectionalLightHelperComponent extends THING.BaseLineSegmentsHelperComponent {
    /**
     * Show/Hide lines.
     */
    visible: boolean;
    /**
     * Get points of line(s).
     */
    points: Number[][];
    /**
     * Get colors of line(s).
     */
    colors: Number[][];
    /**
         * Get bounding box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.boundingBox;
        // @expect(bounding.mode == 'All')
         */
    public boundingBox: BoxHelperResult;
    /**
         * Get oriented box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.orientedBox;
        // @expect(bounding.mode == 'All')
         */
    public orientedBox: BoxHelperResult;
    /**
         * Show/Hide axes helper.
         * @example
         * let box = new THING.Box();
            box.helper.axes = true;
         box.waitForComplete().then(()=>{
            let ret = box.helper.axes;
           // @expect(ret == true);
         })
         */
    public axes: boolean;
    /**
         * Get/Set axes helper length.
         * @example
         * let box = new THING.Box();
            box.helper.axesLength = 10;
            // @expect(box.helper.axesLength == 10);
         */
    public axesLength: number;
    /**
         * Get the light(s)'s config.
         * @example
         * let box = new THING.Box();
            let count = box.helper.lights.length;
            // @expect(count == 0);
         */
    public lights: object[];
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * Load or unload object's resources when show or hide it automaticly.
   */
  class DynamicLoadComponent extends THING.BaseComponent {
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The helper component of object what can show many useful information of it, like axis, bounding box, etc.
   */
  class HelperComponent extends THING.BaseComponent {
    /**
         * Get bounding box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.boundingBox;
        // @expect(bounding.mode == 'All')
         */
    public boundingBox: BoxHelperResult;
    /**
         * Get oriented box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.orientedBox;
        // @expect(bounding.mode == 'All')
         */
    public orientedBox: BoxHelperResult;
    /**
         * Show/Hide axes helper.
         * @example
         * let box = new THING.Box();
            box.helper.axes = true;
         box.waitForComplete().then(()=>{
            let ret = box.helper.axes;
           // @expect(ret == true);
         })
         */
    public axes: boolean;
    /**
         * Get/Set axes helper length.
         * @example
         * let box = new THING.Box();
            box.helper.axesLength = 10;
            // @expect(box.helper.axesLength == 10);
         */
    public axesLength: number;
    /**
         * Get the light(s)'s config.
         * @example
         * let box = new THING.Box();
            let count = box.helper.lights.length;
            // @expect(count == 0);
         */
    public lights: object[];
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The interpolation of object what could do all smoothing transforming jobs.
   */
  class LerpComponent extends THING.BaseComponent {
    /**
     * Start lerp.
     * @param param - The parameters.
     * @param name - The lerp name, if user want to stop it later then need to provide it.
     */
    public to(param: LerpArgs, name: string): void;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The level actions of object, it could process object's action(s) when enter its level.
   */
  class LevelComponent extends THING.BaseComponent {
    /**
         * Get or set the level configuration
         * @example
         * // Get the current level configuration
        let levelComponent  = THING.App.current.root.level;
        levelComponent.config = { ignoreVisible: true, ignoreStyle: false };
        // @expect { levelComponent.config.ignoreVisible === true }
        // @expect { levelComponent.config.ignoreStyle === false }
         */
    public config: LevelConfig;
    /**
         * Gets or sets the local camera position and target position (read from the scene file).
         * @example
         * let levelComponent = THING.App.current.root.level;
        // Get the local viewpoint
        let localViewpoint = levelComponent.localViewpoint;
        let ret1 = typeof localViewpoint === 'object';
        let ret2 = localViewpoint === null;
        // @expect { ret1 == true || ret2 == true }
        
        // Set the local viewpoint
        levelComponent.localViewpoint = {
          position: [0, 0, 0],
          target: [1, 1, 1]
        };
        // @expect {levelComponent.localViewpoint.position[0] === 0 && levelComponent.localViewpoint.target[2] === 1}
         */
    public localViewpoint: Viewpoint;
    /**
         * Gets or sets the world camera viewpoint position and camera target position (read from the scene file).
         * @example
         * let levelComponent = THING.App.current.root.level;
        // Get the world viewpoint
        let viewpoint = levelComponent.viewpoint;
        let ret1 = typeof viewpoint === 'object';
        let ret2 = viewpoint === null;
        // @expect { ret1 == true || ret2 == true }
        
        // Set the world viewpoint
        levelComponent.viewpoint = {
          position: [0, 0, 0],
          target: [1, 1, 1]
        };
        // @expect {levelComponent.viewpoint.position[0] === 0 && levelComponent.viewpoint.target[2] === 1}
         */
    public viewpoint: Viewpoint;
    /**
         * Imports data from an external source.
         * @example
         * let levelComponent = THING.App.current.root.level;
        // Import data from an external source
        // Example 1: Importing data
        levelComponent.onImport({ viewpoint: { position: [1, 2, 3], target: [4, 5, 6] }, config: { ignoreStyle:true, ignoreVisible:false } });
        // @expect { levelComponent.localViewpoint.position[0] === 1 }
        // @expect { levelComponent.localViewpoint.target[2] === 6 }
        // @expect { levelComponent.config.ignoreStyle === true }
        // @expect { levelComponent.config.ignoreVisible === false }
         * @param external - The external data to import.
         */
    public onImport(external: any): void;
    /**
         * Export data to an external source.
         * @example
         * let levelComponent = THING.App.current.root.level;
        levelComponent.onImport({ viewpoint: { position: [1, 2, 3], target: [4, 5, 6] }, config: { ignoreStyle:true, ignoreVisible:false } });
        // Export data to an external source
        let exportedData = levelComponent.onExport();
        // @expect { exportedData.viewpoint.position[1] === 2 }
        // @expect { exportedData.viewpoint.target[0] === 4 }
        // @expect { exportedData.config.ignoreStyle === true }
        let ret = exportedData.config.ignoreVisible == undefined;
        // @expect { ret === true }
         * @returns - The exported data.
         */
    public onExport(): any | null;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * Auto update light attributes.
   */
  class LightAdapterComponent extends THING.BaseComponent {
    /**
     * Enable/Disable.
     */
    enable: boolean;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The model animation player of entity object.
   */
  class ModelAnimationComponent extends THING.BaseComponent {
    /**
         * Check whether has animation by name.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let ret = UinoSpaceman.hasAnimation('Walk');
             // @expect(ret == true);
        });
         * @param name - The animation name
         */
    public hasAnimation(name: string): boolean;
    /**
         * Stop animation.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.stopAnimation('Walk');
          let ret2 = UinoSpaceman.getAnimationState() == 'Stopped';
             // @expect(ret1 == true && ret2 == true);
        });
         * @param name - The animation name.
         */
    public stopAnimation(name: string): void;
    /**
         * Stop all animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.stopAllAnimations();
          let ret2 = UinoSpaceman.getAnimationState() == 'Stopped';
             // @expect(ret1 == true && ret2 == true);
        });
         */
    public stopAllAnimations(): void;
    /**
         * Get all animations info.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let animations = UinoSpaceman.animations;
          let ret = animations[0].name == 'Walk';
             // @expect(ret == true);
        });
         */
    public animations: AnimationResult[];
    /**
         * Get the animation names.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let animations = UinoSpaceman.animationNames;
          let ret = animations[0] == 'Walk';
             // @expect(ret == true);
        });
         */
    public animationNames: String[];
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The model of entity object.
   */
  class ModelResourceComponent extends THING.BaseComponent {
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The helper of base points object in plane.
   * @param param - The initial parameters.
   */
  class PlanePointsHelperComponent extends THING.BaseLineSegmentsHelperComponent {
    constructor(param: any);
    /**
     * Show/Hide helper.
     */
    public visible: boolean;
    /**
     * Get points of line(s).
     */
    points: Number[][];
    /**
     * Get colors of line(s).
     */
    colors: Number[][];
    /**
         * Get bounding box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.boundingBox;
        // @expect(bounding.mode == 'All')
         */
    public boundingBox: BoxHelperResult;
    /**
         * Get oriented box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.orientedBox;
        // @expect(bounding.mode == 'All')
         */
    public orientedBox: BoxHelperResult;
    /**
         * Show/Hide axes helper.
         * @example
         * let box = new THING.Box();
            box.helper.axes = true;
         box.waitForComplete().then(()=>{
            let ret = box.helper.axes;
           // @expect(ret == true);
         })
         */
    public axes: boolean;
    /**
         * Get/Set axes helper length.
         * @example
         * let box = new THING.Box();
            box.helper.axesLength = 10;
            // @expect(box.helper.axesLength == 10);
         */
    public axesLength: number;
    /**
         * Get the light(s)'s config.
         * @example
         * let box = new THING.Box();
            let count = box.helper.lights.length;
            // @expect(count == 0);
         */
    public lights: object[];
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The relationship of object.
   */
  class RelationshipComponent extends THING.BaseComponent {
    /**
         * Query related objects.
         * @example
         * let lightSwitch = new Box();
        let light = new Box();
        let rel = new THING.Relationship({
             type: 'control',
             source: lightSwitch,
             target: light
        })
        lightSwitch.relationship.query({type: 'control'});
         * @param options.type - The type of relationship.
         * @param options.name - The name of relationship.
         * @param options.queryDirection - The query direction.
         */
    public query(options: {
      type: string;
      name: string;
      queryDirection: RelationshipDirection;
    }): THING.Selector;
    /**
         * Query related objects by relationship type.
         * @example
         * let lightSwitch = new Box();
        let light = new Box();
        let rel = new THING.Relationship({
             type: 'control',
             source: lightSwitch,
             target: light,
                name: 'light'
        })
        let objs = lightSwitch.relationship.queryByType('control');
         * @param type - The relationship type.
         * @param queryDirection - The query direction.
         */
    public queryByType(
      type: string,
      queryDirection: RelationshipDirection
    ): THING.Selector;
    /**
         * Query related objects by relationship name.
         * @example
         * let lightSwitch = new Box();
        let light = new Box();
        let rel = new THING.Relationship({
             type: 'control',
             source: lightSwitch,
             target: light,
                name: 'light'
        })
        let objs = lightSwitch.relationship.queryByName('light');
         * @param name - The relationship name.
         * @param queryDirection - The query direction.
         */
    public queryByName(
      name: string,
      queryDirection: RelationshipDirection
    ): THING.Selector;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The render control of object, like using instanced drawing mode.
   */
  class RenderComponent extends THING.BaseComponent {
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * Auto update light position, target and shadow range by binding object's bounding.
   */
  class ShadowLightAdapterComponent extends THING.LightAdapterComponent {
    /**
     * Bind/Unbind object.
     * @param object - The object.
     */
    bind(object: THING.BaseObject): void;
    /**
     * Get/Set the light sphere radius of light position from target, default is null(indicates auto calculate).
     */
    lightSphereRadius: number;
    /**
     * Get/Set the light sphere radius of shadow, default is null(indicates auto calculate).
     */
    lightSphereShadowRadius: number;
    /**
     * Get/Set horz angles from object's bounding box center.
     */
    horzAngle: number;
    /**
     * Get/Set vert angles from object's bounding box center.
     */
    vertAngle: number;
    /**
     * Enable/Disable.
     */
    enable: boolean;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The transform component of light what can cast shadow.
   */
  class ShadowLightTransformComponent extends THING.TransformComponent {
    /**
         * Get/Set the distance of keep size mode.
         * @example
         * let component = new THING.TransformComponent();
        component.keepSizeDistance = 10;
        // @expect(component.keepSizeDistance == 10);
         */
    public keepSizeDistance: number;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The space relation component of object.
   */
  class SpaceHelperComponent extends THING.BaseComponent {
    /**
     * show bounding
     * @example
     * space.showBounding();
     * @param value - The value
     */
    public showBounding(value?: boolean): void;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The space relation component of object.
   */
  class SpaceRelationComponent extends THING.BaseComponent {
    /**
         * contains relation
         * @example
         * let result = this.contains(obj, false);
         console.log(result);
         * @param obj - THe relation object.
         * @param cascade - The cascade.
         */
    public contains(obj: any, cascade?: boolean): boolean;
    /**
         * intersects relation
         * @example
         * let result = this.intersects(obj, false);
         console.log(result);
         * @param obj - THe relation object.
         * @param cascade - The cascade.
         */
    public intersects(obj: any, cascade?: boolean): boolean;
    /**
         * disjoint relation
         * @example
         * let result = this.disjoint(obj, false);
         console.log(result);
         * @param obj - THe relation object.
         * @param cascade - The cascade.
         */
    public disjoint(obj: any, cascade?: boolean): boolean;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The helper component of spot light object, show auxiliary lines of it.
   */
  class SpotLightHelperComponent extends THING.BaseLineSegmentsHelperComponent {
    /**
     * Show/Hide lines.
     */
    visible: boolean;
    /**
     * Get points of line(s).
     */
    points: Number[][];
    /**
     * Get colors of line(s).
     */
    colors: Number[][];
    /**
         * Get bounding box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.boundingBox;
        // @expect(bounding.mode == 'All')
         */
    public boundingBox: BoxHelperResult;
    /**
         * Get oriented box.
         * @example
         * let component = new THING.HelperComponent();
        let bounding = component.orientedBox;
        // @expect(bounding.mode == 'All')
         */
    public orientedBox: BoxHelperResult;
    /**
         * Show/Hide axes helper.
         * @example
         * let box = new THING.Box();
            box.helper.axes = true;
         box.waitForComplete().then(()=>{
            let ret = box.helper.axes;
           // @expect(ret == true);
         })
         */
    public axes: boolean;
    /**
         * Get/Set axes helper length.
         * @example
         * let box = new THING.Box();
            box.helper.axesLength = 10;
            // @expect(box.helper.axesLength == 10);
         */
    public axesLength: number;
    /**
         * Get the light(s)'s config.
         * @example
         * let box = new THING.Box();
            let count = box.helper.lights.length;
            // @expect(count == 0);
         */
    public lights: object[];
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
     * TaskExecutorComponent
    The task executor component.
     */
  class TaskExecutorComponent extends THING.BaseComponent {
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
   * The transform component of object.
   */
  class TransformComponent extends THING.BaseComponent {
    /**
         * Get/Set the distance of keep size mode.
         * @example
         * let component = new THING.TransformComponent();
        component.keepSizeDistance = 10;
        // @expect(component.keepSizeDistance == 10);
         */
    public keepSizeDistance: number;
    /**
     * When initialize callback function.
     */
    onInit: OnInitComponentCallback;
    /**
     * When load resource callback function.
     */
    onLoadResource: OnLoadResourceComponentCallback;
    /**
     * When unload resource callback function.
     */
    onUnloadResource: OnUnloadResourceComponentCallback;
    /**
     * When update callback function.
     */
    onUpdate: OnUpdateComponentCallback;
    /**
     * When change parent callback function.
     */
    onParentChange: OnParentChangeComponentCallback;
    /**
     * When resize callback function.
     */
    onResize: OnResizeComponentCallback;
    /**
     * When refresh callback function.
     */
    onRefresh: OnRefreshComponentCallback;
    /**
     * When active change callback function.
     */
    onActiveChange: OnActiveChangeComponentCallback;
    /**
     * When visible change callback function.
     */
    onVisibleChange: OnVisibleChangeComponentCallback;
    /**
     * When copy callback function.
     */
    onCopy: OnCopyComponentCallback;
    /**
     * When before add child callback function.
     */
    onBeforeAddChild: OnAddChildComponentCallback;
    /**
     * When after add child callback function.
     */
    onAfterAddChild: OnAddChildComponentCallback;
    /**
     * When before remove child callback function.
     */
    onBeforeRemoveChild: OnRemoveChildComponentCallback;
    /**
     * When after remove child callback function.
     */
    onAfterRemoveChild: OnRemoveChildComponentCallback;
    /**
     * Before add.
     */
    onBeforeAdd: OnBeforeAddComponentCallback;
    /**
     * After add.
     */
    onAfterAdd: OnAfterAddComponentCallback;
    /**
     * Before remove.
     */
    onBeforeRemove: OnBeforeRemoveComponentCallback;
    /**
     * After remove.
     */
    onAfterRemove: OnAfterRemoveComponentCallback;
    /**
     * When import data.
     */
    onImport: OnImportComponentCallback;
    /**
     * When export data.
     */
    onExport: OnExportComponentCallback;
    /**
     * When add component.
     * @param object - The object.
     */
    onAdd(object: THING.BaseObject): void;
    /**
     * When remove component.
     */
    onRemove(): void;
    /**
     * Active or deactive component.
     */
    active: boolean;
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get application.
     */
    app: THING.App;
  }
  /**
     * The application constructor.
     * @example
     * // Load bundle scene
    var app = new THING.App({
         url: './scene-bundle',
         onComplete: (e) = {
        console.log(e);
      }
    });
    
    // Load gltf scene
    var app = new THING.App({
      url: './gltf/scene.gltf',
      onComplete: (e) => {
        console.log(e);
      }
    });
     * @param param - The initial parameters.
     */
  class App extends THING.BaseComponentGroup {
    constructor(param: AppOptions);
    /**
         * The current application.
         * @example
         * let app = THING.App.current;
        let ret = app.picker != null;
        // @expect(ret == true);
         */
    current: THING.App;
    /**
         * Add a callback to the end of the app instantiation
         * @example
         * THING.App.addCompleteCallback((app)=>{
                console.log(The app instantiation is complete.);
        },-10);
         * @param callback - The callback.
         * @param priority - The priority. (The default is 0, the smaller one is executed first)
         */
    public static addCompleteCallback(
      callback: (...params: any[]) => any,
      priority: number
    ): void;
    /**
     * Dispose.
     */
    public dispose(): void;
    /**
         * Create Object
         * @example
         * let app =  THING.App.current;
        let box = app.create({
          type: 'Box',
          name: 'box',
          position: [1, 1, 1],
          onComplete: function() {
            console.log('box01 created!');
          }
        });
        let ret = box instanceof THING.Box;
        // @expect(ret == true);
         * @param param - The parameter list
         * @param param.type - Object type
         * @param param.options? - Object create parameters
         */
    public create(param: { type: string; options?: any }): THING.BaseObject;
    /**
         * Load gltf or bundle resource.
         * @example
         * app.load({ url: './assets/scenes/scene.gltf' }).then((ev) => {
            let objs = app.query('.BaseObject');
               let count =  objs.length;
           // @expect(count > 0);
        })
         * @param options - The options.
         * @param options.url - The resource url.
         * @param options.onComplete - The load callback function.
         * @param options.onProgress - The progress callback function.
         * @param options.onError - The error callback function.
         */
    public load(options: {
      url: string;
      onComplete: (...params: any[]) => any;
      onProgress: (...params: any[]) => any;
      onError: (...params: any[]) => any;
    }): Promise;
    /**
         * Load from URL or data.
         * @example
         * app.load({ url: './blueprints/myBP.json' });
        app.run();
         * @param options - The options.
         * @param url - The resource URL(s).
         * @param data - The json data.
         */
    loadBlueprint(options: any, url: string | String[], data: any): void;
    /**
         * Get the picker.
         * @example
         * let picker = app.picker;
        // @expect(picker != null)
        picker.enable = false;
        // @expect(picker.enable == false)
         */
    public picker: THING.Picker;
    /**
         * Get the level manager.
         * @example
         * let app = THING.App.current;
        let level = app.level;
        let target = app.query('.Entity')[0];
        level.change(target, {
          onComplete: function(){
                let ret = level.current == target;
                // @expect(ret == true);
          }
        });
         */
    public level: THING.LevelManager;
    /**
         * Capture screen shot into pixel buffer in RGBA color format.
         * @example
         * let data = THING.App.current.captureScreenshotToData(640, 480);
         let ret = data.length == (640 * 480 * 4);
         // @expect(ret == true);
         * @param width - The image width in pixel, if it not provide then use the current width.
         * @param height - The image height in pixel, if it not provide then use the current height.
         */
    captureScreenshotToData(width: number, height: number): Uint8Array;
    /**
         * Capture screen shot into image.
         * @example
         * let image = THING.App.current.captureScreenshotToImage(640, 480);
            let ret1 = image instanceof Image;
         let ret2 = image.width == 640 && image.height == 480;
         THING.Utils.setTimeout(() => {
            // @expect(ret1 == true && ret2 == true);
            }, 100);
         * @param width - The image width in pixel.
         * @param height - The image height in pixel.
         */
    captureScreenshotToImage(width: number, height: number): any;
    /**
     * Capture screen shot into file.
     * @example
     * THING.App.current.captureScreenshotToFile('cameraCapture', 640, 480);
     * @param fileName - The file name.
     * @param width - The image width in pixel.
     * @param height - The image height in pixel.
     */
    captureScreenshotToFile(
      fileName: string,
      width: number,
      height: number
    ): void;
    /**
         * Get the container.
         * @example
         * //the html div id is div3d
        let id = THING.App.current.container.id;
        let ret = id == 'div3d';
        // @expect(ret == true);
         */
    container: any;
    /**
         * Get the size.
         * @example
         * //the div3d size is 1024*768
        let size = THING.App.current.size;
             // @expect(size[0] == 1024 && size[1] == 768);
         */
    size: Number[];
    /**
         * Get the root.
         * @example
         * let root = THING.App.current.root;
         // @expect(root.isRootObject == true)
         */
    root: THING.RootObject;
    /**
         * get all relationships
         * @example
         * let app = THING.App.current;
         let count1 = app.relationships.length;
         app.relationshipManager.addRelationship({
                source: app.root,
                target: app.root
         })
         let count2 = app.relationships.length;
         let ret = count2 - count1;
         // @expect(ret == 1)
         */
    public readonly relationships: THING.Relationship[];
    /**
         * Get/Set the camera.
         * @example
         * let camera = new THING.Camera();
        camera.far = 100;
        THING.App.current.camera = camera;
        let ret = THING.App.current.camera.far == 100;
        // @expect(ret == true)
         */
    camera: THING.Camera;
    /**
         * Get/Set pixel ratio.
        Set/Get Pixel Ratio The default is 1, and it can be set to a value between 0-1.
        The larger the value, the clearer the rendering effect (lower frame rate),
        The smaller the value, the blurrier the rendering (increased frame rate)
        On mobile devices, in order to render the frame rate, app.pixelRatio can be set to a value less than 1.
         */
    pixelRatio: number;
    /**
         * Find children by conditions and returns the first one.
         * @example
         * let obj = THING.App.current.find('.BaseObject');
         let ret = obj instanceof THING.BaseObject;
        // @expect(ret == true)
         let cylinder = THING.App.current.find('.Cylinder');
         ret = cylinder == null;
        // @expect(ret == true)
         * @param condition - The conditions.
         */
    public find(condition: string): THING.BaseObject;
    /**
         * Query children by condition.
         * @example
         * let obj = THING.App.current.query('.BaseObject');
         let ret = obj[0] instanceof THING.BaseObject;
        // @expect(ret == true)
         let cylinder = THING.App.current.query('.Cylinder');
         ret = cylinder.length == 0;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public query(
      condition: string | RegExp,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let car = THING.App.current.queryByName('car01')
            let ret = car.length == 0;
            // @expect(ret == true)
         car = THING.App.current.queryByName('car1')
         ret = car[0].name == 'car1';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(condition: string, options: any): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let car = THING.App.current.queryById('1')
            let ret = car.length == 0;
         // @expect(ret == true);
         car = THING.App.current.queryById('car01')
         ret = car[0].id == 'car01';
         // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(condition: string, options: any): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let car = THING.App.current.queryByTags('car');
            let ret = car.length == 0;
         // @expect(ret == true)
            let entity = THING.App.current.queryByTags('Entity');
            ret = entity[0].tags.has('Entity');
         // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(condition: string, options: any): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let car = app.queryByUUID('1')
            let ret = car.length == 0;
         // @expect(ret == true);
         car = app.queryByUUID('1605')
         ret = car[0].uuid == '1605';
         // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(condition: string, options: any): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let car = THING.App.current.queryByType('car')
            let ret = car.length == 0;
        // @expect(ret == true)
         let obj = THING.App.current.queryByType('Entity')
         ret = obj[0].type == 'Entity';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(condition: string, options: any): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let car = THING.App.current.queryByUserData('test=1');
            let ret = car.length == 0;
         // @expect(ret == true)
         car = THING.App.current.queryByUserData('id=666');
         ret = car[0].userData.id == 666;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(condition: string, options: any): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let car = THING.App.current.queryByRegExp(/car/);
            let ret = car.length == 4;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(condition: string, options: any): THING.Selector;
    /**
         * Query relationships.
         * @example
         * let lightSwitch = new THING.Box();
        let light = new THING.Box();
        let rel = new THING.Relationship({
             type: 'control',
             source: lightSwitch,
             target: light
        });
        let relationships = app.queryRelationships({type: 'control'});
        let ret1 = relationships[0].source == lightSwitch;
        let ret2 = relationships[0].target == light;
        // @expect(ret1 == true && ret2 == true);
         * @param options - The options.
         * @param options.type - The type of relationship.
         * @param options.name - The name of relationship.
         */
    public queryRelationships(options: {
      type: string;
      name: string;
    }): Relationship[];
    /**
         * Register event.
         * @example
         * let app = THING.App.current;
        let markOn = 0;
        app.on('testOn', function(ev) {
                markOn = 1;
        });
        app.trigger('testOn');
        // @expect(markOn == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first)
         * @param options - The options.
         * @param options.useCapture - True indicates capture all same events from children.
         */
    public on(
      type: string,
      condition: string,
      callback: EventCallback,
      tag: string,
      priority: number,
      options: {
        useCapture: boolean;
      }
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let app = THING.App.current;
        let markOnce = 0;
        app.once('testOnce', function(ev) {
                markOnce = 1;
        });
        app.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        app.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first)
         * @param options - The options.
         * @param options.useCapture - True indicates capture all same events from children.
         */
    public once(
      type: string,
      condition: string,
      callback: EventCallback,
      tag: string,
      priority: number,
      options: {
        useCapture: boolean;
      }
    ): void;
    /**
         * Unregister event.
         * @example
         * let app = THING.App.current;
        let markOff = 0;
        app.on('testOff', function(ev) {
                markOff = 1;
        });
        app.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        app.off('testOff');
        app.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let app = THING.App.current;
        let markPause = 0;
        app.on('testPause', function(ev) {
                markPause = 1;
        });
        app.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        app.pauseEvent('testPause');
        app.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): boolean;
    /**
         * Resume event.
         * @example
         * let app = THING.App.current;
        let markResume = 0;
        app.on('testResume', function(ev) {
                markResume = 1;
        });
        app.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        app.pauseEvent('testResume');
        app.trigger('testResume');
        // @expect(markResume == 0);
        app.resumeEvent('testResume');
        app.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): boolean;
    /**
         * Trigger event.
         * @example
         * let markTrigger = {};
            THING.App.current.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            THING.App.current.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options - The options.
         */
    public trigger(type: string, ev: any, options: any): any;
    /**
         * Get/Set the background.
         * @example
         * THING.App.current.background = 'gray';
        let ret = THING.App.current.background instanceof Array;
        // @expect(ret == true )
         */
    public background: number | string | Number[] | THING.ImageTexture;
    /**
         * Get/Set the default environment map of scene.
         * @example
         * THING.App.current.background = new THING.CubeTexture('./skyboxes/bluesky');
        let ret = THING.App.current.background.url == './skyboxes/bluesky';
        // @expect(ret == true )
         */
    public envMap: THING.CubeTexture;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The global information.
   * @param param - The initial parameters.
   */
  class Global {
    constructor(param: any);
  }
  /**
   * The logo controller.
   */
  class Logo {}
  /**
   * The picker to pick object(s).
   */
  class Picker {
    /**
         * Enable/Disable picker.
         * @example
         * THING.App.current.picker.enable = false;
        let ret = THING.App.current.picker.enable == false;
        // @expect(ret == true);
         */
    public enable: boolean;
  }
  /**
   * The scene of object(s).
   * @param param - The initial parameters.
   */
  class Scene {
    constructor(param: any);
    /**
         * Get/Set the environment map light intensity between 0 and 1.
         * @example
         * app.scene.envMapLightIntensity = 0.5;
            // @expect(app.scene.envMapLightIntensity == 0.5);
         */
    envMapLightIntensity: number;
    /**
         * Get/Set the ambient light.
         * @example
         * let app = THING.App.current;
            app.scene.ambientLight.color = 'blue';
            app.scene.ambientLight.intensity = 0.1;
         let ret1 = app.scene.ambientLight.color == 'blue';
         let ret2 = app.scene.ambientLight.intensity == 0.1;
        // @expect(ret1 == true && ret2 == true);
         */
    ambientLight: THING.AmbientLight;
  }
  /**
     * System
    The system.
     */
  class System {}
  /**
     * BaseBoxHelper
    The box helper object.
     */
  class BaseBoxHelper {}
  /**
   * The helper to show in scene.
   */
  class BaseHelper {
    /**
     * Get lines.
     */
    lines: any;
    /**
     * Get/Set visible.
     */
    visible: boolean;
    /**
     * Get/Set color.
     */
    color: number | string | Number[];
  }
  /**
     * BaseSphereHelper
    The sphere helper object.
     */
  class BaseSphereHelper {}
  /**
   * The bounding box helper of object, it can show bounding box in scene.
   */
  class ObjectBoxHelper extends THING.BaseBoxHelper {
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get/Set mode type.
     */
    mode: BoxHelperModeType;
  }
  /**
   * The collider box helper of object, it can show collider box in scene.
   */
  class ObjectColliderBoxHelper extends THING.BaseBoxHelper {}
  /**
   * The collider sphere helper of object, it can show collider sphere in scene.
   */
  class ObjectColliderSphereHelper {
    /**
     * Get/Set segements.
     */
    segements: number;
  }
  /**
   * The oriented box helper of object, it can show oriented box in scene.
   */
  class ObjectOrientedBoxHelper extends THING.ObjectBoxHelper {
    /**
     * Get object.
     */
    object: THING.BaseObject;
    /**
     * Get/Set mode type.
     */
    mode: BoxHelperModeType;
  }
  /**
   * The base level control class.
   */
  class BaseLevelControl {
    /**
     * When entering the level.
     * @param param - Enter the parameters of the level.
     */
    public onEnter(param: any): void;
    /**
     * When leaving the level.
     * @param param - Leave the parameters of the level.
     */
    public onLeave(param: any): void;
    /**
     * Get whether it is running
     */
    isRunning: boolean;
  }
  /**
   * The resource bundle object what supports js script by loading with specified loader.
   * @param param - The initial parameters.
   */
  class Bundle {
    constructor(param: any);
    /**
         * Check whether had been loaded.
         * @example
         * if (bundle.loaded) {
            console.log('bundle has loaded');
        }
         */
    loaded: boolean;
    /**
         * Check whether it's loading.
         * @example
         * if (bundle.loading) {
            console.log('bundle is loading');
        }
         */
    loading: boolean;
    /**
     * Get the unique ID.
     * @example
     * console.log(bundle.uuid);
     */
    uuid: string;
    /**
     * Get the resource url.
     * @example
     * console.log(bundle.url);
     */
    url: string;
    /**
     * Get the options.
     * @example
     * console.log(bundle.options);
     */
    options: any;
    /**
         * Get the main info.
         * @example
         * let info = bundle.info;
        let name = bundle.name;
        console.log(`Bundle's name is '${name$}'`);
         */
    info: any;
  }
  /**
     * ActionManager
    The action manager.
     */
  class ActionManager {
    /**
     * Register action.
     * @param name - The action unique name.
     * @param action - The action.
     */
    register(name: string, action: THING.BaseAction): void;
    /**
     * Unregister action.
     * @param name - The action unique name.
     */
    unregister(name: string): void;
    /**
         * Run actions.
         * @example
         * app.actionManager.run([
                {
                    type: 'CameraFlyTo',
                    params: {
                        position: [10, 10, 5],
                        target: [0, 0, 0],
                        time: 1000
                    },
                    delay: 1000,
                    waitForComplete: true
                },
                {
                    type: 'CreateObject',
                    params: {
                        type: 'Box',
                        name: 'box01'
                    },
                    delay: 1000,
                    waitForComplete: true
                },
                {
                    type: 'ObjectSetColor',
                    target: 'box01',
                    params: {
                        color: 'red'
                    },
                    delay: 1000,
                    waitForComplete: true
                }
            ]);
         * @param messages - The messages data.
         */
    run(messages: ActionMessageData[]): void;
  }
  /**
     * BlueprintManager
    The blueprint manager.
     */
  class BlueprintManager {}
  /**
   * The event manager to register, unregister or trigger event(s).
   */
  class EventManager {}
  /**
   * The level manager to manage object(s) throught between parent and child object.
   */
  class LevelManager {
    /**
         * Change current level.
         * @example
         * let app = THING.App.current;
        let level = app.level;
        let target = app.query('.Entity')[0];
        level.change(target, {
          onComplete: function(){
                let ret = level.current == target;
                // @expect(ret == true);
          }
        });
         * @param object - The object.
         * @param options - The options.
         */
    public change(object: THING.BaseObject, options: LevelChangeOptions): void;
    /**
         * Change current level in async mode.
         * @example
         * let app = THING.App.current;
        let level = app.level;
        let target = app.query('.Entity')[0];
        level.changeAsync(target, {
          onComplete: function(){
                let ret = level.current == target;
                // @expect(ret == true);
          }
        });
         * @param object - The object.
         * @param options - The options.
         */
    changeAsync(
      object: THING.BaseObject,
      options: LevelChangeOptions
    ): Promise<any>;
    /**
         * Change to the parent level.
         * @example
         * let app = THING.App.current;
        let level = app.level;
        let target = app.query('.Entity')[0];
        level.change(target, {
          onComplete: function(){
                let ret = level.current == target;
                // @expect(ret == true);
                level.back({
                onComplete: function(){
                        ret = level.current == target.parent;
                        // @expect(ret == true)
                }
                });
          }
        });
         * @param options - The options.
         */
    public back(options: LevelChangeOptions): void;
    /**
         * Change to the parent level in async mode.
         * @example
         * let app = THING.App.current;
        let level = app.level;
        let target = app.query('.Entity')[0];
        level.change(target, {
          onComplete: function(){
                let ret = level.current == target;
                // @expect(ret == true);
                level.backAsync({
                onComplete: function(){
                        ret = level.current == target.parent;
                        // @expect(ret == true)
                }
                });
          }
        });
         * @param options - The options.
         */
    backAsync(options: LevelChangeOptions): Promise<any>;
    /**
         * Quit.
         * @example
         * let app = THING.App.current;
        let level = app.level;
        level.quit({
          onComplete: function(){
                let ret = level.current == null;
                // @expect(ret == true);
          }
        });
         */
    public quit(): Promise<any>;
    /**
     * Register level control
     * @param condition - Query conditions (The level control will apply to query results)
     * @param control - The level control
     * @param options - The level control options
     */
    public register(
      condition: string,
      control: THING.BaseLevelControl,
      options: RegisterControlOptions
    ): void;
    /**
     * Unregister level control
     * @param condition - Query conditions
     * @param tag - The level control tag.
     */
    public unregister(condition: string, tag: string): void;
    /**
         * Enable/Disable level manager.
         * @example
         * let app = THING.App.current;
        let level = app.level;
        level.enable = false;
        let target = app.query('.Entity')[0];
        level.change(target);
        let ret = level.isChanging;
        // @expect(ret == false);
         */
    enable: boolean;
    /**
         * Get the previous object.
         * @example
         * let app = THING.App.current;
        let level = app.level;
        let prev = level.prev;
        let target = app.query('.Entity')[0];
        level.change(target, {
          onComplete: function(){
                let ret = level.prev == prev;
                // @expect(ret == true);
             }
        });
         */
    public prev: THING.BaseObject;
    /**
         * Get the current object.
         * @example
         * let app = THING.App.current;
        let level = app.level;
        let target = app.query('.Entity')[0];
        level.change(target, {
          onComplete: function(){
                let ret = level.current == target;
                // @expect(ret == true);
             }
        });
         */
    public current: THING.BaseObject;
    /**
         * Check whether is changing level.
         * @example
         * let app = THING.App.current;
        let level = app.level;
        let target = app.query('.Entity')[0];
        level.change(target);
        let ret = level.isChanging;
        // @expect(ret == true);
         */
    public isChanging: boolean;
  }
  /**
   * The object manager to manage object(s) life.
   */
  class ObjectManager {}
  /**
   * The relationship manager to manage object(s) life.
   */
  class RelationshipManager {}
  /**
   * The tween manager to update value(s) smoothly.
   */
  class TweenManager {
    /**
     * Start lerp to.
     * @param from - The source.
     * @param to - The target.
     * @param [duration = 1000] - The lerp time in milliseconds.
     * @param [delayTime = 0] - The delay time in milliseconds.
     */
    lerpTo(
      from: number | any,
      to: number | any,
      duration?: number,
      delayTime?: number
    ): LerpToResult;
  }
  /**
   * The math utils.
   */
  class MathUtils {}
  /**
   * The ambient light object, just only need 1 in the scene normally.
   * @param param - The initial parameters.
   */
  class AmbientLight extends THING.BaseLight {
    constructor(param: any);
    /**
         * Check whether it's AmbientLight type or inherit from it.
         * @example
         * let point = new THING.AttachedPoint();
        let ret = point.isAttachedPoint;
        // @expect(ret == true);
         */
    public isAmbientLight: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The attached point object, it would ignore angels and scales from parent.
   * @param param - The initial parameters.
   */
  class AttachedPoint extends THING.BaseTickableObject3D {
    constructor(param: any);
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
         * Check whether it's AttachedPoint type or inherit from it.
         * @example
         * let point = new THING.AttachedPoint();
        let ret = point.isAttachedPoint;
        // @expect(ret == true);
         */
    public isAttachedPoint: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base container in scene.
   */
  class BaseContainer3D extends THING.BaseObject {
    /**
         * Check whether it's BaseContainer3D type or inherit from it.
         * @example
         * let point = new THING.BaseContainer3D();
        let ret = point.isBaseContainer3D;
        // @expect(ret == true);
         */
    isBaseContainer3D: boolean;
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set name.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.name == '');
        object.name = 'car';
        // @expect(object.name == 'car');
         */
    public name: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Add object as child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object what you want to add.
         * @param options - The options.
         */
    public add(object: THING.BaseObject, options: any): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base points object.
   * @param param - The initial parameters.
   */
  class BaseDynamicPoints extends THING.BasePoints {
    constructor(param: any);
    /**
         * Check whether it's BaseDynamicPoints type or inherit from it.
         * @example
         * let point = new THING.BaseDynamicPoints();
        let ret = point.isBaseDynamicPoints;
        // @expect(ret == true);
         */
    isBaseDynamicPoints: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base entity object that load 3D model resource in scene.
   * @param param - The initial parameters.
   */
  class BaseEntity extends THING.Object3D {
    constructor(param: any);
    /**
         * Get all animations info.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let animations = UinoSpaceman.animations;
          let ret = animations[0].name == 'Walk';
             // @expect(ret == true);
        });
         */
    animations: AnimationResult[];
    /**
         * Get the animation names.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let animations = UinoSpaceman.animationNames;
          let ret = animations[0] == 'Walk';
             // @expect(ret == true);
        });
         */
    animationNames: String[];
    /**
         * Play animation, would stop all other animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret = UinoSpaceman.isAnimationPlaying('Walk');
             // @expect(ret == true);
        });
         * @param param - The parameters.
         */
    playAnimation(param: PlayAnimationArgs): void;
    /**
     * Blends animation, would not stop all other animations.
     * @param param - The parameters.
     */
    blendAnimation(param: PlayAnimationArgs): void;
    /**
         * Check whether has animation by name.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let ret = UinoSpaceman.hasAnimation('Walk');
             // @expect(ret == true);
        });
         * @param name - The animation name
         */
    hasAnimation(name: string): boolean;
    /**
         * Check whether animation is playing.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret = UinoSpaceman.isAnimationPlaying('Walk');
             // @expect(ret == true);
        });
         * @param name - The animation name
         */
    isAnimationPlaying(name: string): boolean;
    /**
         * Pause animation(s).
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.pauseAnimation('Walk');
          let ret2 = UinoSpaceman.getAnimationState() == 'Paused';
             // @expect(ret1 == true && ret2 == true);
        });
         * @param name - The animation name or name list.
         */
    pauseAnimation(name: string | String[]): void;
    /**
         * Pause all animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.pauseAllAnimations();
          let ret2 = UinoSpaceman.getAnimationState() == 'Paused';
             // @expect(ret1 == true && ret2 == true);
        });
         */
    pauseAllAnimations(): void;
    /**
         * Resume animation(s).
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.pauseAnimation('Walk');
          let ret2 = UinoSpaceman.getAnimationState() == 'Paused';
             UinoSpaceman.resumeAnimation('Walk');
          let ret3 = UinoSpaceman.isAnimationPlaying('Walk');
             // @expect(ret1 == true && ret2 == true && ret3 == true);
        });
         * @param name - The animation name or name list.
         */
    resumeAnimation(name: string | String[]): void;
    /**
         * Resume all animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.pauseAnimation('Walk');
          let ret2 = UinoSpaceman.getAnimationState() == 'Paused';
             UinoSpaceman.resumeAllAnimations();
          let ret3 = UinoSpaceman.isAnimationPlaying('Walk');
             // @expect(ret1 == true && ret2 == true && ret3 == true);
        });
         */
    resumeAllAnimations(): void;
    /**
         * Stop animation.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.stopAnimation('Walk');
          let ret2 = UinoSpaceman.getAnimationState() == 'Stopped';
             // @expect(ret1 == true && ret2 == true);
        });
         * @param name - The animation name.
         */
    stopAnimation(name: string): void;
    /**
         * Stop all animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.stopAllAnimations();
          let ret2 = UinoSpaceman.getAnimationState() == 'Stopped';
             // @expect(ret1 == true && ret2 == true);
        });
         */
    stopAllAnimations(): void;
    /**
         * Get animation info.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let animation = UinoSpaceman.getAnimation('Walk');
          let ret = animation.name == 'Walk';
             // @expect(ret == true);
        });
         * @param name - The animation name.
         */
    getAnimation(name: string): AnimationResult;
    /**
         * Get animation state.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let state = UinoSpaceman.getAnimationState('Walk');
          let ret = state == 'Playing';
             // @expect(ret == true);
        });
         * @param name - The animation name.
         */
    getAnimationState(name: string): PlayStateType;
    /**
         * Get playing animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let animations = UinoSpaceman.getPlayingAnimations();
          let ret = animations[0].state == 'Playing';
             // @expect(ret == true);
        });
         */
    getPlayingAnimations(): AnimationResult[];
    /**
     * Get animation direction type.
     * @param name - The animation name.
     */
    getAnimationDirectionType(name: string): AnimationDirectionType;
    /**
     * Set animation direction type.
     * @param name - The animation name.
     * @param value - The direction type.
     */
    setAnimationDirectionType(
      name: string,
      value: AnimationDirectionType
    ): boolean;
    /**
         * Get animation speed.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat", speed: 10 });
          let speed = UinoSpaceman.getAnimationSpeed('Walk');
          let ret = speed == 10;
             // @expect(ret == true);
        });
         * @param name - The animation name.
         */
    getAnimationSpeed(name: string): number;
    /**
         * Set animation speed.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat", speed: 10 });
             UinoSpaceman.setAnimationSpeed('Walk', 20)
          let speed = UinoSpaceman.getAnimationSpeed('Walk');
          let ret = speed == 20;
             // @expect(ret == true);
        });
         * @param name - The animation name.
         * @param value - The speed.
         */
    setAnimationSpeed(name: string, value: number): boolean;
    /**
         * Promote node as child object.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let obj = UinoSpaceman.promoteNode('pasted__head');
             let ret1 = obj instanceof THING.BaseEntity;
          let ret2 = obj.name == 'pasted__head';
             // @expect(ret1 == true && ret2 == true);
        });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    promoteNode(name: string, parent: THING.Object3D): THING.BaseEntity;
    /**
         * Check whether it's BaseEntity type or inherit from it.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        let ret = UinoSpaceman.isBaseEntity;
        // @expect(ret == true);
         */
    isBaseEntity: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base light object.
   * @param param - The initial parameters.
   */
  class BaseLight extends THING.BaseTickableObject3D {
    constructor(param: any);
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base line object.
   * @param param - The initial parameters.
   */
  class BaseLine extends THING.BaseDynamicPoints {
    constructor(param: any);
    /**
         * Check whether it's BaseDynamicPoints type or inherit from it.
         * @example
         * let point = new THING.BaseDynamicPoints();
        let ret = point.isBaseDynamicPoints;
        // @expect(ret == true);
         */
    isBaseDynamicPoints: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
     * BaseModelObject3D
    The base model object 3D.
     */
  class BaseModelObject3D extends THING.Object3D {
    /**
         * Check whether it's BaseModelObject3D type or inherit from it.
         * @example
         * let obj = new THING.BaseModelObject3D();
        let ret = obj.isBaseModelObject3D;
        // @expect(ret == true)
         */
    isBaseModelObject3D: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base object.
   * @param param - The initial parameters.
   */
  class BaseObject extends THING.BaseComponentGroup {
    constructor(param: BaseObjectInitialOptions);
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set name.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.name == '');
        object.name = 'car';
        // @expect(object.name == 'car');
         */
    public name: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Add object as child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object what you want to add.
         * @param options - The options.
         */
    public add(object: THING.BaseObject, options: any): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base points object in plane.
   * @param param - The initial parameters.
   */
  class BasePlanePoints extends THING.BaseDynamicPoints {
    constructor(param: any);
    /**
     * Get/Set the holes in world space.
     */
    holes: Number[][][];
    /**
     * Get the area.
     */
    area: number;
    /**
     * Get the perimeter.
     */
    perimeter: number;
    /**
     * Get the label position in world space.
     */
    labelPosition: Number[];
    /**
     * Get the outline points in plane.
     */
    outlinePoints: Number[][];
    /**
         * Check whether it's BaseDynamicPoints type or inherit from it.
         * @example
         * let point = new THING.BaseDynamicPoints();
        let ret = point.isBaseDynamicPoints;
        // @expect(ret == true);
         */
    isBaseDynamicPoints: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * This is a constructor function.
   */
  class BasePlugin {
    /**
         * The use of the "static" keyword means that the variable belongs to the class rather than to an instance of the class.
         * @example
         * let plug = new THING.BasePlugin()
        let ret = THING.BasePlugin.isBasePlugin;
        // @expect(ret == true)
         */
    isBasePlugin: boolean;
  }
  /**
   * The base points object.
   * @param param - The initial parameters.
   */
  class BasePoints extends THING.Object3D {
    constructor(param: any);
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base light object that can cast shadow.
   * @param param - The initial parameters.
   */
  class BaseShadowLight extends THING.BaseLight {
    constructor(param: any);
    /**
     * Enable/Disable cast shadow.
     */
    castShadow: boolean;
    /**
     * Get/Set shadow quality.
     */
    shadowQuality: ShadowQualityType | number;
    /**
     * Get/Set shadow bias.
     */
    shadowBias: number;
    /**
     * Get/Set shadow range.
     */
    shadowRange: ShadowRangeInfo;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base tickable object that can invoke onUpdate() automaticly.
   * @param param - The initial parameters.
   */
  class BaseTickableObject extends THING.BaseObject {
    constructor(param: any);
    /**
         * Check whether it's BaseTickableObject type or inherit from it.
         * @example
         * let obj = new THING.BaseTickableObject()
        let ret = obj.isBaseTickableObject;
        // @expect(ret == true)
         */
    isBaseTickableObject: boolean;
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set name.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.name == '');
        object.name = 'car';
        // @expect(object.name == 'car');
         */
    public name: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Add object as child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object what you want to add.
         * @param options - The options.
         */
    public add(object: THING.BaseObject, options: any): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The base tickable object that can invoke onUpdate() automaticly in scene.
   * @param param - The initial parameters.
   */
  class BaseTickableObject3D extends THING.Object3D {
    constructor(param: any);
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The body object to access object's self renderable node(s).
   */
  class BodyObject {
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Object3D();
        let ret = object.body.visible == true;
        // @expect(ret == true)
        object.body.visible = false;
        ret = object.body.visible == false;
        // @expect(ret == true)
         */
    visible: boolean;
    /**
         * Get/Set local(offset) position of the parent space.
         * @example
         * let object = new THING.Object3D();
        let ret = object.body.localPosition[1] == 0;
        // @expect(ret == true)
            object.body.localPosition = [0, 10, 0];
        ret = object.body.localPosition[1] == 10;
        // @expect(ret == true)
         */
    localPosition: Number[];
    /**
         * Get/Set quaternion of the inertial space.
         * @example
         * let object = new THING.Object3D();
        let ret = object.body.localQuaternion[1] == 0;
        // @expect(ret == true)
            object.body.localQuaternion = [0, 10, 0, 1];
        ret = object.body.localQuaternion[1] == 10;
        // @expect(ret == true)
            object.body.localQuaternion = [0, 10, 0, 1];
         */
    localQuaternion: Number[];
    /**
         * Get/Set angles of the inertial space.
         * @example
         * let object = new THING.Object3D();
        let ret = object.body.localAngles[1] == 0;
        // @expect(ret == true)
            object.body.localAngles = [0, 10, 0];
        ret = object.body.localAngles[1] == 10;
        // @expect(ret == true)
         */
    localAngles: Number[];
    /**
         * Get/Set scale of the self coordinate system.
         * @example
         * let object = new THING.Object3D();
        let ret = object.body.localScale[1] == 1;
        // @expect(ret == true)
            object.body.localScale = [10, 10, 10];
        ret = object.body.localScale[1] == 10;
        // @expect(ret == true)
         */
    localScale: Number[];
    /**
         * Get/Set world position of the world space.
         * @example
         * let object = new THING.Object3D();
        let ret = object.body.position[1] == 0;
        // @expect(ret == true)
            object.body.position = [10, 10, 10];
        ret = object.body.position[1] == 10;
        // @expect(ret == true)
         */
    position: Number[];
    /**
         * Get/Set angles of the world space.
         * @example
         * let object = new THING.Object3D();
        let ret = object.body.angles[1] == 0;
        // @expect(ret == true)
            object.body.angles = [10, 10, 10];
        ret = object.body.angles[1] == 10;
        // @expect(ret == true)
         */
    angles: Number[];
    /**
         * Get/Set scale of the world coordinate system.
         * @example
         * let object = new THING.Object3D();
        let ret = object.body.scale[1] == 1;
        // @expect(ret == true)
            object.body.scale = [10, 10, 10];
        ret = object.body.scale[1] == 10;
        // @expect(ret == true)
         */
    scale: Number[];
    /**
         * Get/Set the transform.
         * @example
         * let object = new THING.Object3D();
        let ret = object.body.matrix[12] == 0;
        // @expect(ret == true)
            object.body.matrix =THING.Math.mat4.fromTranslation([], [10, 10, 10]);
        ret = object.body.matrix[12] == 10;
        // @expect(ret == true)
         */
    matrix: Number[];
    /**
         * Get/Set the world transform.
         * @example
         * let object = new THING.Object3D();
        let ret = object.body.matrixWorld[12] == 0;
        // @expect(ret == true)
            object.body.matrixWorld =THING.Math.mat4.fromTranslation([], [10, 10, 10]);
        ret = object.body.matrixWorld[12] == 10;
        // @expect(ret == true)
         */
    matrixWorld: Number[];
    /**
         * Get/Set style of body.
         * @example
         * let object = new THING.Object3D();
            let style = object.body.style;
            style.color = 'red';
            style.opacity = 0.1;
         let ret = object.body.style.color[0] == 1;
         // @expect(ret == true)
         ret = object.body.style.opacity == 0.1;
         // @expect(ret == true)
         */
    style: THING.Style;
  }
  /**
   * The box object in scene.
   * @param width - The width, default is 1.
   * @param height - The height, default is 1.
   * @param depth - The depth, default is 1.
   * @param param - The initial parameters.
   */
  class Box extends THING.BaseModelObject3D {
    constructor(width: number, height: number, depth: number, param: any);
    /**
         * Get/Set the width.
         * @example
         * let box = new THING.Box();
        // @expect(box.width == 1)
        box.width = 10;
        // @expect(box.width == 10)
         */
    width: number;
    /**
         * Get/Set the height.
         * @example
         * let box = new THING.Box();
        // @expect(box.height == 1)
        box.height = 10;
        // @expect(box.height == 10)
         */
    height: number;
    /**
         * Get/Set the depth.
         * @example
         * let box = new THING.Box();
        // @expect(box.depth == 1)
        box.depth = 10;
        // @expect(box.depth == 10)
         */
    depth: number;
    /**
         * Check whether it's box object.
         * @example
         * let box = new THING.Box();
        let ret = box.isBox;
        // @expect(ret == true)
         */
    isBox: boolean;
    /**
         * Check whether it's BaseModelObject3D type or inherit from it.
         * @example
         * let obj = new THING.BaseModelObject3D();
        let ret = obj.isBaseModelObject3D;
        // @expect(ret == true)
         */
    isBaseModelObject3D: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The camera object in scene.
   * @param param - The initial parameters.
   */
  class Camera extends THING.Object3D {
    constructor(param: any);
    /**
         * Convert world position to screen position.
         * @example
         * let screen0 = THING.App.current.camera.worldToScreen([100, 100, 90]);
            let screen1 = THING.App.current.camera.worldToScreen([100, 100, 100]);
            if (screen0 < screen1) {
                console.log('screen0 is closer to the camera than screen1');
            }
         * @param position - The world position.
         * @returns The screen position in [x, y, z] format, [z] indicates the sort order for 2D element.
         */
    public worldToScreen(position: Number[]): Number[];
    /**
     * Convert screen position to world position.
     * @example
     * let position = THING.App.current.camera.screenToWorld([100, 100]);
     * @param screenPosition - The screen position.
     */
    public screenToWorld(screenPosition: Number[]): Number[];
    /**
         * Capture to render texture.
         * @example
         * let renderTexture = THING.App.current.camera.captureToRenderTexture();
        renderTexture.download('myScreenshot');
         * @param width - The image width in pixel, if it not provide then use the current width.
         * @param height - The image height in pixel, if it not provide then use the current height.
         */
    public captureToRenderTexture(
      width: number,
      height: number
    ): THING.RenderTexture;
    /**
     * Capture render result to pixel buffer in RGBA color format.
     * @example
     * let data = THING.App.current.camera.captureToData(1024, 768);
     * @param width - The image width in pixel, if it not provide then use the current width.
     * @param height - The image height in pixel, if it not provide then use the current height.
     */
    public captureToData(width: number, height: number): Uint8Array;
    /**
     * Capture render result into image.
     * @example
     * let image = THING.App.current.camera.captureToImage(1024, 768);
     * @param width - The image width in pixel, if it not provide then use the current width.
     * @param height - The image height in pixel, if it not provide then use the current height.
     */
    public captureToImage(width: number, height: number): any;
    /**
     * Capture render result to file(PNG format) in download mode.
     * @example
     * THING.App.current.camera.captureToFile('myScreenshot');
     * @param fileName - The file name.
     * @param width - The image width in pixel, if it not provide then use the current width.
     * @param height - The image height in pixel, if it not provide then use the current height.
     */
    public captureToFile(fileName: string, width: number, height: number): void;
    /**
         * Enable/Disable viewport.
         * @example
         * let camera = new THING.Camera();
        camera.enableViewport = true;
         */
    public enableViewport: boolean;
    /**
         * Get/Set viewport of screen [x, y, width, height].
         * @example
         * let camera = new THING.Camera();
        camera.viewport = [0, 0, 100, 100];
         */
    public viewport: Number[];
    /**
         * Get/Set render texture.
         * @example
         * let renderTexture = new THING.RenderTexture({
                size: THING.App.current.size
            });
        
            let camera = new THING.Camera();
            camera.renderTexture = renderTexture;
         */
    public renderTexture: THING.RenderTexture;
    /**
     * Get projection type.
     * @example
     * let projectionType = THING.App.current.camera.getProjectionType();
     */
    public getProjectionType(): ProjectionType;
    /**
     * Set projection type.
     * @example
     * THING.App.current.camera.setProjectionType(THING.ProjectionType.Orthographic);
     * @param value - The projection value.
     * @param duration - The projection matrix lerping time in milliseconds.
     */
    public setProjectionType(value: ProjectionType, duration?: number): void;
    /**
     * Get view mode type.
     * @example
     * let viewMode = THING.App.current.camera.getViewMode();
     */
    public getViewMode(): ViewMode;
    /**
     * Set view mode type.
     * @example
     * THING.App.current.camera.setViewMode(THING.App.current.root, THING.ViewModeType.Top);
     * @param target - The target object, if do not provide then would use level's current object or root object.
     * @param value - The view mode value.
     * @param duration - The projection matrix lerping time in milliseconds.
     */
    public setViewMode(
      target: THING.Object3D,
      value: ViewMode,
      duration?: number
    ): void;
    /**
     * Get/Set fov.
     * @example
     * THING.App.current.camera.fov = 60;
     */
    public fov: number;
    /**
     * Get/Set near.
     * @example
     * THING.App.current.camera.near = 0.001;
     */
    public near: number;
    /**
     * Get/Set far.
     * @example
     * THING.App.current.camera.far = 1000000;
     */
    public far: number;
    /**
     * Get aspect.
     * @example
     * let aspect = THING.App.current.camera.aspect;
     */
    public readonly aspect: number;
    /**
     * Get/Set projection type.
     * @example
     * THING.App.current.camera.projectionType = THING.ProjectionType.Orthographic;
     */
    public projectionType: ProjectionType;
    /**
     * Get/Set view mode type.
     * @example
     * THING.App.current.camera.viewMode = THING.ViewModeType.Top;
     */
    public viewMode: ViewMode;
    /**
         * Check intersection between object and region.
         * @example
         * if (THING.App.current.camera.intersectObjectInRegion([0, 0, 100, 100], object)) {
            console.log('intersect OK');
        }
         * @param region - The [left, top, width, height] region in screen.
         * @param object - The object.
         */
    public intersectObjectInRegion(
      region: Number[],
      object: THING.Object3D
    ): boolean;
    /**
         * Pick node.
         * @example
         * let result = THING.App.current.camera.pick(100, 100);
            if (result) {
                console.log('picked result: ', result.object);
            }
         * @param x - The x coordinate in screen.
         * @param y - The y coordinate in screen.
         * @param root? - The root object to pick.
         */
    public pick(x: number, y: number, root?: THING.BaseObject): PickResult;
    /**
         * Pick from cross planes.
         * @example
         * let result = THING.App.current.camera.pickFromCrossPlanes(100, 100);
            if (result) {
                console.log('picked result: ', result.object);
            }
         * @param x - The x coordinate in screen.
         * @param y - The y coordinate in screen.
         * @param isVertical - Whether vertical and horizontal planes will always be vertical.
         */
    public pickFromCrossPlanes(
      x: number,
      y: number,
      isVertical?: boolean
    ): PickResult;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The capsule object in scene.
   * @param param - The initial parameters.
   */
  class Capsule extends THING.Mesh {
    constructor(param: any);
    /**
     * Set the vertex of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.position) interface when the geometry is shared.
     */
    public setPosition(array: Number[] | Float32Array): void;
    /**
     * Get the vertex of the mesh.
     */
    public getPosition(): Float32Array;
    /**
     * Set the vertex uv of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.uv) interface when the geometry is shared.
     */
    public setUv(array: Number[] | Float32Array): void;
    /**
     * Get the vertex uv of the mesh.
     */
    public getUv(): Float32Array;
    /**
     * Set the vertex normal of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.normal) interface when the geometry is shared.
     */
    public setNormal(array: Number[] | Float32Array): void;
    /**
     * Get the vertex normal of the mesh.
     */
    public getNormal(): Float32Array;
    /**
     * Get mesh data.
     */
    public data: any;
    /**
     * Check whether it's Mesh type or inherit from it.
     */
    public isMesh: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The circle object in scene.
   * @param param - The initial parameters.
   */
  class Circle extends THING.Mesh {
    constructor(param: any);
    /**
     * Set the vertex of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.position) interface when the geometry is shared.
     */
    public setPosition(array: Number[] | Float32Array): void;
    /**
     * Get the vertex of the mesh.
     */
    public getPosition(): Float32Array;
    /**
     * Set the vertex uv of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.uv) interface when the geometry is shared.
     */
    public setUv(array: Number[] | Float32Array): void;
    /**
     * Get the vertex uv of the mesh.
     */
    public getUv(): Float32Array;
    /**
     * Set the vertex normal of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.normal) interface when the geometry is shared.
     */
    public setNormal(array: Number[] | Float32Array): void;
    /**
     * Get the vertex normal of the mesh.
     */
    public getNormal(): Float32Array;
    /**
     * Get mesh data.
     */
    public data: any;
    /**
     * Check whether it's Mesh type or inherit from it.
     */
    public isMesh: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The clipping planes that use with object style to clip object by planes.
   * @param param - The initial parameters.
   */
  class ClippingPlanes extends THING.BaseTickableObject3D {
    constructor(param: any);
    /**
     * Get/Set the clipping planes.
     */
    public planes: ClippingPlaneResult[];
    /**
     * Check whether it's ClippingPlanes type or inherit from it.
     */
    public isClippingPlanes: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The cylinder object in scene.
   * @param param - The initial parameters.
   */
  class Cylinder extends THING.Mesh {
    constructor(param: any);
    /**
     * Set the vertex of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.position) interface when the geometry is shared.
     */
    public setPosition(array: Number[] | Float32Array): void;
    /**
     * Get the vertex of the mesh.
     */
    public getPosition(): Float32Array;
    /**
     * Set the vertex uv of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.uv) interface when the geometry is shared.
     */
    public setUv(array: Number[] | Float32Array): void;
    /**
     * Get the vertex uv of the mesh.
     */
    public getUv(): Float32Array;
    /**
     * Set the vertex normal of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.normal) interface when the geometry is shared.
     */
    public setNormal(array: Number[] | Float32Array): void;
    /**
     * Get the vertex normal of the mesh.
     */
    public getNormal(): Float32Array;
    /**
     * Get mesh data.
     */
    public data: any;
    /**
     * Check whether it's Mesh type or inherit from it.
     */
    public isMesh: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The directional light object in scene.
   * @param param - The initial parameters.
   */
  class DirectionalLight extends THING.BaseShadowLight {
    constructor(param: any);
    /**
     * Check whether it's DirectionalLight type or inherit from it.
     */
    public isDirectionalLight: boolean;
    /**
     * Enable/Disable cast shadow.
     */
    castShadow: boolean;
    /**
     * Get/Set shadow quality.
     */
    shadowQuality: ShadowQualityType | number;
    /**
     * Get/Set shadow bias.
     */
    shadowBias: number;
    /**
     * Get/Set shadow range.
     */
    shadowRange: ShadowRangeInfo;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The prefabe object that load prefab resource in scene.
   * @param param - The initial parameters.
   */
  class Entity extends THING.BaseEntity {
    constructor(param: any);
    /**
         * Get all animations info.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let animations = UinoSpaceman.animations;
          let ret = animations[0].name == 'Walk';
             // @expect(ret == true);
        });
         */
    animations: AnimationResult[];
    /**
         * Get the animation names.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let animations = UinoSpaceman.animationNames;
          let ret = animations[0] == 'Walk';
             // @expect(ret == true);
        });
         */
    animationNames: String[];
    /**
         * Play animation, would stop all other animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret = UinoSpaceman.isAnimationPlaying('Walk');
             // @expect(ret == true);
        });
         * @param param - The parameters.
         */
    playAnimation(param: PlayAnimationArgs): void;
    /**
     * Blends animation, would not stop all other animations.
     * @param param - The parameters.
     */
    blendAnimation(param: PlayAnimationArgs): void;
    /**
         * Check whether has animation by name.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let ret = UinoSpaceman.hasAnimation('Walk');
             // @expect(ret == true);
        });
         * @param name - The animation name
         */
    hasAnimation(name: string): boolean;
    /**
         * Check whether animation is playing.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret = UinoSpaceman.isAnimationPlaying('Walk');
             // @expect(ret == true);
        });
         * @param name - The animation name
         */
    isAnimationPlaying(name: string): boolean;
    /**
         * Pause animation(s).
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.pauseAnimation('Walk');
          let ret2 = UinoSpaceman.getAnimationState() == 'Paused';
             // @expect(ret1 == true && ret2 == true);
        });
         * @param name - The animation name or name list.
         */
    pauseAnimation(name: string | String[]): void;
    /**
         * Pause all animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.pauseAllAnimations();
          let ret2 = UinoSpaceman.getAnimationState() == 'Paused';
             // @expect(ret1 == true && ret2 == true);
        });
         */
    pauseAllAnimations(): void;
    /**
         * Resume animation(s).
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.pauseAnimation('Walk');
          let ret2 = UinoSpaceman.getAnimationState() == 'Paused';
             UinoSpaceman.resumeAnimation('Walk');
          let ret3 = UinoSpaceman.isAnimationPlaying('Walk');
             // @expect(ret1 == true && ret2 == true && ret3 == true);
        });
         * @param name - The animation name or name list.
         */
    resumeAnimation(name: string | String[]): void;
    /**
         * Resume all animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.pauseAnimation('Walk');
          let ret2 = UinoSpaceman.getAnimationState() == 'Paused';
             UinoSpaceman.resumeAllAnimations();
          let ret3 = UinoSpaceman.isAnimationPlaying('Walk');
             // @expect(ret1 == true && ret2 == true && ret3 == true);
        });
         */
    resumeAllAnimations(): void;
    /**
         * Stop animation.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.stopAnimation('Walk');
          let ret2 = UinoSpaceman.getAnimationState() == 'Stopped';
             // @expect(ret1 == true && ret2 == true);
        });
         * @param name - The animation name.
         */
    stopAnimation(name: string): void;
    /**
         * Stop all animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let ret1 = UinoSpaceman.isAnimationPlaying('Walk');
          UinoSpaceman.stopAllAnimations();
          let ret2 = UinoSpaceman.getAnimationState() == 'Stopped';
             // @expect(ret1 == true && ret2 == true);
        });
         */
    stopAllAnimations(): void;
    /**
         * Get animation info.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let animation = UinoSpaceman.getAnimation('Walk');
          let ret = animation.name == 'Walk';
             // @expect(ret == true);
        });
         * @param name - The animation name.
         */
    getAnimation(name: string): AnimationResult;
    /**
         * Get animation state.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let state = UinoSpaceman.getAnimationState('Walk');
          let ret = state == 'Playing';
             // @expect(ret == true);
        });
         * @param name - The animation name.
         */
    getAnimationState(name: string): PlayStateType;
    /**
         * Get playing animations.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat" });
          let animations = UinoSpaceman.getPlayingAnimations();
          let ret = animations[0].state == 'Playing';
             // @expect(ret == true);
        });
         */
    getPlayingAnimations(): AnimationResult[];
    /**
     * Get animation direction type.
     * @param name - The animation name.
     */
    getAnimationDirectionType(name: string): AnimationDirectionType;
    /**
     * Set animation direction type.
     * @param name - The animation name.
     * @param value - The direction type.
     */
    setAnimationDirectionType(
      name: string,
      value: AnimationDirectionType
    ): boolean;
    /**
         * Get animation speed.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat", speed: 10 });
          let speed = UinoSpaceman.getAnimationSpeed('Walk');
          let ret = speed == 10;
             // @expect(ret == true);
        });
         * @param name - The animation name.
         */
    getAnimationSpeed(name: string): number;
    /**
         * Set animation speed.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          UinoSpaceman.playAnimation({ name: 'Walk', loopType: "Repeat", speed: 10 });
             UinoSpaceman.setAnimationSpeed('Walk', 20)
          let speed = UinoSpaceman.getAnimationSpeed('Walk');
          let ret = speed == 20;
             // @expect(ret == true);
        });
         * @param name - The animation name.
         * @param value - The speed.
         */
    setAnimationSpeed(name: string, value: number): boolean;
    /**
         * Promote node as child object.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        UinoSpaceman.waitForComplete().then(() => {
          let obj = UinoSpaceman.promoteNode('pasted__head');
             let ret1 = obj instanceof THING.BaseEntity;
          let ret2 = obj.name == 'pasted__head';
             // @expect(ret1 == true && ret2 == true);
        });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    promoteNode(name: string, parent: THING.Object3D): THING.BaseEntity;
    /**
         * Check whether it's BaseEntity type or inherit from it.
         * @example
         * var UinoSpaceman = new THING.Entity({url:'.assets/models/UinoSpaceman/UinoSpaceman.gltf'});
        let ret = UinoSpaceman.isBaseEntity;
        // @expect(ret == true);
         */
    isBaseEntity: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The extrude shape object that create polygon shape by height in scene.
   * @param param - The initial parameters.
   */
  class ExtrudeShape extends THING.BaseDynamicPoints {
    constructor(param: any);
    /**
     * Get/Set the holes in self space.
     */
    public selfHoles: Number[][][];
    /**
     * Get/Set the holes in world space.
     */
    public holes: Number[][][];
    /**
     * Get/Set the height.
     */
    public height: number;
    /**
         * Check whether it's BaseDynamicPoints type or inherit from it.
         * @example
         * let point = new THING.BaseDynamicPoints();
        let ret = point.isBaseDynamicPoints;
        // @expect(ret == true);
         */
    isBaseDynamicPoints: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The fat line object in scene.
   * @param param - The initial parameters.
   */
  class FatLine extends THING.BaseLine {
    constructor(param: any);
    /**
     * Get/Set width.
     */
    public width: number;
    /**
     * Get/Set corner threshold in (0, 1].
     */
    public cornerThreshold: number;
    /**
         * Check whether it's BaseDynamicPoints type or inherit from it.
         * @example
         * let point = new THING.BaseDynamicPoints();
        let ret = point.isBaseDynamicPoints;
        // @expect(ret == true);
         */
    isBaseDynamicPoints: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * THe hemisphere light object in scene.
   * @param param - The initial parameters.
   */
  class HemisphereLight extends THING.BaseLight {
    constructor(param: any);
    /**
     * Get/Set ground color.
     */
    public groundColor: number | string | Number[];
    /**
     * Check whether it's HemisphereLight type or inherit from it.
     */
    isHemisphereLight: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The label object that show text in plane in scene.
   * @param param - The initial parameters.
   */
  class Label extends THING.Marker {
    constructor(param: any);
    /**
     * Get/Set font text.
     */
    public fontText: string;
    /**
     * Get/Set font type.
     */
    public fontType: string;
    /**
     * Get/Set font size.
     */
    public fontSize: number;
    /**
     * Get/Set font line width.
     */
    public fontLineWidth: number;
    /**
     * Get/Set font line height, 0 indicates use font size auto.
     */
    public fontLineHeight: number;
    /**
     * Get/Set font color.
     */
    public fontColor: number | string | Number[];
    /**
     * Get/Set font shadow color.
     */
    public fontShadowColor: number | string | Number[];
    /**
     * Get/Set font shadow alpha.
     */
    public fontShadowAlpha: number;
    /**
     * Get/Set font shadow angle.
     */
    public fontShadowAngle: number;
    /**
     * Get/Set font shadow blur.
     */
    public fontShadowBlur: number;
    /**
     * Get/Set font shadow distance.
     */
    public fontShadowDistance: number;
    /**
     * Get/Set font align type.
     */
    public fontAlignType: AlignType;
    /**
     * Enable/Disable rich text.
     */
    public richText: boolean;
    /**
     * Get/Set font weight.
     */
    public fontWeight: FontWeight;
    /**
         * Enable/Disable auto fit body scale, true indicates it will use the ratio of style's image size to fit body scale.
        Default value is: false.
         * @example
         * marker.autoFitBodyScale = true;
         */
    public autoFitBodyScale: boolean;
    /**
         * Get/Set scale factor of autoFitBodyScale attribute(only works when [autoFitBodyScale=true]).
        Default value is: 0.01.
         * @example
         * marker.scaleFactor = 0.1;
         */
    public scaleFactor: number;
    /**
     * Get/Set the render type.
     */
    public renderType: RenderType;
    /**
     * Get/Set the sprite rotation in degree, only works on THING.RenderType.Sprite mode.
     */
    public spriteRotation: number;
    /**
     * Get/Set before fit body scale callback function.
     */
    public onBeforeFitBodyScale: OnFitBodyScaleCallback;
    /**
     * Get/Set after fit body scale callback function.
     */
    public onAfterFitBodyScale: OnFitBodyScaleCallback;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The lensflare object.
   * @param param - The initial parameters.
   */
  class Lensflare extends THING.Object3D {
    constructor(param: any);
    /**
     * Get/Set the occlusion scale of lensflare.
     */
    occlusionScale: number;
    /**
     * Add element
     * @param element - The lensflare element.
     */
    addElement(element: LensflareElement): void;
    /**
     * Remove element by index.
     * @param index - The lensflare element at this index will be removed.
     */
    removeElement(index: number): void;
    /**
     * Clear the elements of lensflare.
     */
    clearElements(): void;
    /**
     * Get all elements of lensflare.
     */
    getAllElements(): LensflareElement[];
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The marker object that show image in scene.
   * @param param - The initial parameters.
   */
  class Marker extends THING.Object3D {
    constructor(param: any);
    /**
         * Enable/Disable auto fit body scale, true indicates it will use the ratio of style's image size to fit body scale.
        Default value is: false.
         * @example
         * marker.autoFitBodyScale = true;
         */
    public autoFitBodyScale: boolean;
    /**
         * Get/Set scale factor of autoFitBodyScale attribute(only works when [autoFitBodyScale=true]).
        Default value is: 0.01.
         * @example
         * marker.scaleFactor = 0.1;
         */
    public scaleFactor: number;
    /**
     * Get/Set the render type.
     */
    public renderType: RenderType;
    /**
     * Get/Set the sprite rotation in degree, only works on THING.RenderType.Sprite mode.
     */
    public spriteRotation: number;
    /**
     * Get/Set before fit body scale callback function.
     */
    public onBeforeFitBodyScale: OnFitBodyScaleCallback;
    /**
     * Get/Set after fit body scale callback function.
     */
    public onAfterFitBodyScale: OnFitBodyScaleCallback;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The mesh object that with custom geometry info in scene.
   * @param param - The initial parameters.
   */
  class Mesh extends THING.Object3D {
    constructor(param: any);
    /**
     * Set the vertex of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.position) interface when the geometry is shared.
     */
    public setPosition(array: Number[] | Float32Array): void;
    /**
     * Get the vertex of the mesh.
     */
    public getPosition(): Float32Array;
    /**
     * Set the vertex uv of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.uv) interface when the geometry is shared.
     */
    public setUv(array: Number[] | Float32Array): void;
    /**
     * Get the vertex uv of the mesh.
     */
    public getUv(): Float32Array;
    /**
     * Set the vertex normal of the mesh.Use the current interface when the geometry references only itself, and use the attribute (mesh.geometry.normal) interface when the geometry is shared.
     */
    public setNormal(array: Number[] | Float32Array): void;
    /**
     * Get the vertex normal of the mesh.
     */
    public getNormal(): Float32Array;
    /**
     * Get mesh data.
     */
    public data: any;
    /**
     * Check whether it's Mesh type or inherit from it.
     */
    public isMesh: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The sub node object that to get meshes from renderable object in scene.
   * @param param - The initial parameters.
   */
  class NodeObject {
    constructor(param: any);
    /**
     * Convert local position to self position.
     * @param position - The local position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public localToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to local position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToLocal(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert local position to world position.
     * @param position - The local position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public localToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert world position to local position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToLocal(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Get/Set local position.
     * @example
     * object.body.nodes[0].localPosition = [10, 10, 10];
     */
    public localPosition: Number[];
    /**
     * Get/Set local quaternion.
     * @example
     * object.body.nodes[0].localQuaternion = THING.Math.getQuatFromAngles([45, 45, 45]);
     */
    public localQuaternion: Number[];
    /**
     * Get/Set local angles.
     * @example
     * object.body.nodes[0].localAngles = [45, 45, 45];
     */
    public localAngles: Number[];
    /**
     * Get/Set local scale.
     * @example
     * object.body.nodes[0].localScale = [3, 3, 3];
     */
    public localScale: Number[];
    /**
     * Get/Set world position.
     * @example
     * object.body.nodes[0].position = [10, 10, 10];
     */
    public position: Number[];
    /**
     * Get/Set world quaternion.
     * @example
     * object.body.nodes[0].quaternion = THING.Math.getQuatFromAngles([45, 45, 45]);
     */
    public quaternion: Number[];
    /**
     * Get/Set world angles.
     * @example
     * object.body.nodes[0].angles = [45, 45, 45];
     */
    public angles: Number[];
    /**
     * Get/Set world scale.
     * @example
     * object.body.nodes[0].scale = [3, 3, 3];
     */
    public scale: Number[];
    /**
     * Get/Set matrix.
     * @example
     * object.body.nodes[0].matrix = THING.Math.composeToMat4([10, 10, 10], [0, 0, 0, 1], [2, 2, 2]);
     */
    public matrix: Number[];
    /**
     * Get/Set matrix world.
     * @example
     * object.body.nodes[0].matrixWorld = THING.Math.composeToMat4([10, 10, 10], [0, 0, 0, 1], [2, 2, 2]);
     */
    public matrixWorld: Number[];
  }
  /**
   * The base object in scene.
   * @param param - The initial parameters.
   */
  class Object3D extends THING.BaseObject {
    constructor(param: Object3DInitialOptions);
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
     * ParticleEmitter
    The particle emitter.
     * @example
     * const emitter = new THING.ParticleEmitter();
    emitter.particleCount = 100;
    emitter.distribution = 1;
    emitter.duration = 2;
    emitter.isLookAtCamera = true;
    emitter.isLookAtCameraY = true;
    emitter.wiggle = {
        spread:0,
        value:0
    };
    emitter.rotation = {
        axisSpread:[0, 0, 0],
        randomise:false,
        angleSpread:0,
        center:[0, 0, 0],
        angle:0,
        static:false,
        axis:[0, 1, 0]
    };
    emitter.velocity = {
        randomise:false,
        value:[0, 25, 0],
        distribution:1,
        spread:[10, 7.5, 10]
    };
    emitter.size = {
        randomise:[false, false],
        spread:[0, 0],
        value:[2, 0]
    };
    emitter.angle = {
        randomise:[false, false],
        spread:[0, 0],
        value:[1, 0]
    };
    emitter.opacity = {
        randomise:[false, false],
        spread:[0, 0],
        value:[1, 0.1]
    };
    emitter.color = {
        randomise:[false, false],
        spread:[[0, 0, 0], [0, 0, 0]],
        value:[[0, 0, 0], [1, 1, 0]]
    };
    emitter.acceleration = {
        randomise:false,
        value:[0, -10, 0],
        distribution:1,
        spread:[0, 0, 0]
    };
    emitter.maxAge = {
        spread:0,
        value:2
    };
    emitter.position = {
     randomise:false,
     radius:10,
     spreadClamp:[0, 0, 0],
     value:[0, 0, -50],
     radiusScale:[1, 1, 1],
     distribution:1,
     spread:[0, 0, 0]
    };
    emitter.drag = {
     randomise:false,
     spread:0,
     value:0
    };
     */
  class ParticleEmitter {
    /**
     * Get attribute.
     * @param key - The key
     */
    public getAttribute(key: ParticleEmitterAttributeType): any;
    /**
     * Set attribute.
     * @param key - The key
     * @param value - The value.
     */
    public setAttribute(key: ParticleEmitterAttributeType, value: any): void;
    /**
     * Get/Set particle count.The count of particle when rendering.
     */
    public particleCount: number;
    /**
     * Get/Set direction.The direction of the particle. If value is `1`, particle will start at beginning of particle's lifecycle.If value is `-1`, particle will start at end of particle's lifecycle and work it's way backwards.
     */
    public direction: number;
    /**
     * Get/Set isStatic.True indicates these particles should be not be simulated.
     */
    public isStatic: boolean;
    /**
     * Get/Set active multiplier.A value between 0 and 1 describing what percentage of this particle's particlesPerSecond should be emitted, where 0 is 0%, and 1 is 100%.
     */
    public activeMultiplier: number;
    /**
     * Get/Set distribution.It use to control its particle's spawn position and force behaviour.The options are 1(Box),2(Sphere),3(Disc),4(Line).
     */
    public distribution: number;
    /**
     * Get/Set duration.The duration in seconds that this emitter should live for.If not specified, the emitter will emit particles indefinitely.
     */
    public duration: number | null;
    /**
     * Get/Set IsLookAtCamera.It takes effect when UseMesh is true.True indicates its particle will always look at camera.
     */
    public isLookAtCamera: boolean;
    /**
     * Get/Set IsLookAtCamera.It takes effect when UseMesh is true.True indicates its particle will always look at camera and lock y-axis.
     */
    public isLookAtCameraY: boolean;
    /**
     * Get/Set maxAge attribute.
     */
    public maxAge: MaxAge;
    /**
     * Get position.
     */
    public position: Position;
    /**
     * Get rotation.
     */
    public rotation: Rotation;
    /**
     * Get velocity.
     */
    public velocity: Velocity;
    /**
     * Get color.
     */
    public color: ListColor;
    /**
     * Get opacity.
     */
    public opacity: ListOpacity;
    /**
     * Get size.
     */
    public size: ListSize;
    /**
     * Get angle.
     */
    public angle: ListAngle;
    /**
     * Get acceleration.
     */
    public acceleration: Acceleration;
    /**
     * Get drag attribute.
     */
    public drag: Drag;
  }
  /**
     * ParticleGroup
    The particle group.
     * @example
     * const group = new THING.ParticleGroup();
    group.maxParticleCount = 200;
    group.useMesh = false;
    group.meshUrl = "BuildIn/Box";
    group.texture = {
        url:"./particle.png"
    };
    group.blendingMode = "normal";
    group.isTransparent = true;
    group.alphaTest = true;
    group.depthWrite = false;
    group.depthTest = false;
    group.url = "./particle.png";
     */
  class ParticleGroup {
    /**
     * Get attribute.
     * @param key - The key.
     */
    public getAttribute(key: ParticleGroupAttributeType): any;
    /**
     * Set attribute.
     * @param key - The key.
     * @param value - The value.
     */
    public setAttribute(key: ParticleGroupAttributeType, value: any): void;
    /**
         * Add emitter.
         * @example
         * const emitter = new THING.ParticelEmitter();
        group.addEmitter(emitter);
         * @param emitter - The emitter.
         */
    public addEmitter(emitter: ParticleEmitter): ParticleEmitter;
    /**
         * Remove emitter by ParticleEmitter.
         * @example
         * const emitter = group.getEmitters();
        group.removeEmitter(emitter);
         * @param emitter - The emitter.
         */
    public removeEmitter(emitter: ParticleEmitter): void;
    /**
     * Get emitters.
     */
    public emitters: ParticleEmitter[];
    /**
     * Get/Set maxParticleCount.The max count of these particle.
     */
    public maxParticleCount: number;
    /**
     * Get/Set useMesh.True indicates these particle use mesh but not points.
     */
    public useMesh: boolean;
    /**
     * Get/Set mesh url.It takes effect when UseMesh is true, and indicates particle mesh type.The options are 'BuildIn/Box', 'BuildIn/Plane', 'BuildIn/Sphere'.
     */
    public meshUrl: string;
    /**
     * Get/Set mesh parmas.It takes effect when UseMesh is true, and indicates particle mesh type's attribute.
     */
    public meshParams: any[];
    /**
     * Get/Set texture.The image value of particle.
     */
    public texture: ImageTextureResource;
    /**
     * Get/Set textureAnimation.
     */
    public textureAnimation: TextureAnimation;
    /**
     * Get/Set blend mode.The blend mode of these particle.The options are 'none', 'normal', 'add', 'sub', 'mul', 'custom'.
     */
    public blendingMode: string;
    /**
     * Get/Set isTransparent.True indicates these particle's should be rendered with transparency.
     */
    public isTransparent: boolean;
    /**
     * Get/Set isColorize.True indicates these particles should be rendered with color, or the only color of particles will come from the provided texture.
     */
    public isColorize: boolean;
    /**
     * Get/Set alphaTest.Sets the alpha value to particle. Value between 0 and 1.
     */
    public alphaTest: number;
    /**
     * Get/Set depthWrite.Sets the depthWrite to particle.
     */
    public depthWrite: boolean;
    /**
     * Get/Set depthTest.Sets the depthTest to particle.
     */
    public depthTest: boolean;
    /**
     * Get/Set texture url.The image url of particle.
     */
    public url: string;
    /**
     * Get/Set fog.True indicates these particles should be affected by their scene's fog.
     */
    public fog: boolean;
  }
  /**
   * The particle system object in scene.
   * @param param - The initial parameters.
   */
  class ParticleSystem extends THING.BaseTickableObject3D {
    constructor(param: any);
    /**
         * Add group.
         * @example
         * const group = new THING.ParticleGroup();
            particleSystem.addGroup(group);
         * @param group - The group.
         */
    addGroup(group: ParticleGroup): ParticleGroup;
    /**
         * Remove group.
         * @example
         * const groups = particleSystem.getGroups();
            particleSystem.removeGroup(groups[0]);
         * @param group - The group.
         */
    removeGroup(group: ParticleGroup): void;
    /**
     * Get current ParticleSystem data.
     * @example
     * const data = particleSystem.getParticleData({ dataVersion2:false });
     * @param param - { dataVersion2:false } Get data for thingjs2.0 when dataVersion2 is true.
     * @returns ParticleSystem data
     */
    getParticleData(param: any): any;
    /**
     * Get groups.
     */
    public groups: ParticleGroup[];
    /**
     * Check whether it's ParticleSystem type or inherit from it.
     */
    public isParticleSystem: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The pixel line object in scene.
   * @param param - The initial parameters.
   */
  class PixelLine extends THING.BaseLine {
    constructor(param: any);
    /**
     * Check whether it's PixelLine type or inherit from it.
     */
    isPixelLine: boolean;
    /**
         * Check whether it's BaseDynamicPoints type or inherit from it.
         * @example
         * let point = new THING.BaseDynamicPoints();
        let ret = point.isBaseDynamicPoints;
        // @expect(ret == true);
         */
    isBaseDynamicPoints: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The pixel line segments that with points and colors in scene.
   * @param param - The initial parameters.
   */
  class PixelLineSegments extends THING.BasePoints {
    constructor(param: any);
    /**
     * Check whether it's PixelLineSegments type or inherit from it.
     */
    isPixelLineSegments: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The plane object in scene.
   * @param width - The width, default is 1.
   * @param height - The height, default is 1.
   * @param param - The initial parameters.
   */
  class Plane extends THING.BaseModelObject3D {
    constructor(width: number, height: number, param: any);
    /**
     * Get/Set the width.
     */
    width: number;
    /**
     * Get/Set the height.
     */
    height: number;
    /**
     * Check whether it's plane object.
     */
    isPlane: boolean;
    /**
         * Check whether it's BaseModelObject3D type or inherit from it.
         * @example
         * let obj = new THING.BaseModelObject3D();
        let ret = obj.isBaseModelObject3D;
        // @expect(ret == true)
         */
    isBaseModelObject3D: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The plane region with points in scene.
   * @param param - The initial parameters.
   */
  class PlaneRegion extends THING.BasePlanePoints {
    constructor(param: any);
    /**
     * Check whether it's PlaneRegion type or inherit from it.
     */
    isPlaneRegion: boolean;
    /**
     * Get/Set the holes in world space.
     */
    holes: Number[][][];
    /**
     * Get the area.
     */
    area: number;
    /**
     * Get the perimeter.
     */
    perimeter: number;
    /**
     * Get the label position in world space.
     */
    labelPosition: Number[];
    /**
     * Get the outline points in plane.
     */
    outlinePoints: Number[][];
    /**
         * Check whether it's BaseDynamicPoints type or inherit from it.
         * @example
         * let point = new THING.BaseDynamicPoints();
        let ret = point.isBaseDynamicPoints;
        // @expect(ret == true);
         */
    isBaseDynamicPoints: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The points object in scene.
   * @param param - The initial parameters.
   */
  class Points extends THING.BasePoints {
    constructor(param: any);
    /**
     * Get/Set the size.
     */
    size: number;
    /**
     * Get/Set the image ratio.
     */
    imageRatio: number;
    /**
     * Enable/Disable the size attenuation.
     */
    sizeAttenuation: boolean;
    /**
     * Get/Set the picked Ids.
     */
    pickedIds: Number[];
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The polygon line object in scene.
   * @param param - The initial parameters.
   */
  class PolygonLine extends THING.BaseLine {
    constructor(param: any);
    /**
     * Get/Set radius, default is 0.1 (Can not be negative number).
     */
    radius: number;
    /**
     * Get/Set radius of corner (Should be greater than radius).
     */
    cornerRadius: number;
    /**
     * Get/Set split of corner, only works with integer type.
     */
    cornerSplit: number;
    /**
     * Get/Set radial segments (Must be integer type and greater than 2).
     */
    radialSegments: number;
    /**
     * Get/Set start of degree.
     */
    startDegree: number;
    /**
         * Check whether it's BaseDynamicPoints type or inherit from it.
         * @example
         * let point = new THING.BaseDynamicPoints();
        let ret = point.isBaseDynamicPoints;
        // @expect(ret == true);
         */
    isBaseDynamicPoints: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The root object of all objects.
   * @param param - The initial parameters.
   */
  class RootObject extends THING.Object3D {
    constructor(param: any);
    /**
     * Check whether it's RootObject type or inherit from it.
     */
    isRootObject: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The route line object in scene.
   * @param param - The initial parameters.
   */
  class RouteLine extends THING.BaseLine {
    constructor(param: any);
    /**
     * Get/Set the facing direction of self space.
     */
    facingDirection: Number[];
    /**
     * Get/Set width.
     */
    width: number;
    /**
     * Get/Set radius of corner (Should be greater than half of width).
     */
    cornerRadius: number;
    /**
     * Get/Set split of corner, only works with integer type.
     */
    cornerSplit: number;
    /**
     * Enable/Disable arrow.
     */
    arrow: number;
    /**
         * Check whether it's BaseDynamicPoints type or inherit from it.
         * @example
         * let point = new THING.BaseDynamicPoints();
        let ret = point.isBaseDynamicPoints;
        // @expect(ret == true);
         */
    isBaseDynamicPoints: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The space3D object.
   * @param param - The initial parameters.
   */
  class Space3D extends THING.Object3D {
    constructor(param: any);
    /**
         * contains relation
         * @example
         * let result = this.contains(obj, false);
         console.log(result);
         * @param obj - THe relation object.
         * @param cascade - The cascade.
         */
    contains(obj: any, cascade?: boolean): boolean;
    /**
         * intersects relation
         * @example
         * let result = this.intersects(obj, false);
         console.log(result);
         * @param obj - THe relation object.
         * @param cascade - The cascade.
         */
    intersects(obj: any, cascade?: boolean): boolean;
    /**
         * disjoint relation
         * @example
         * let result = this.disjoint(obj, false);
         console.log(result);
         * @param obj - THe relation object.
         * @param cascade - The cascade.
         */
    disjoint(obj: any, cascade?: boolean): boolean;
    /**
     * show bounding
     * @example
     * space.showBounding();
     * @param value - The value, default is true.
     */
    showBounding(value?: boolean): void;
    /**
     * The object size
     */
    size: Number[];
    /**
     * Check whether it's Space3D type or inherit from it.
     */
    isSpace3D: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The sphere object in scene.
   * @param radius - The radius, default is 0.5.
   * @param param - The initial parameters.
   */
  class Sphere extends THING.BaseModelObject3D {
    constructor(radius: number, param: any);
    /**
     * Get/Set the radius.
     */
    radius: number;
    /**
     * Check whether it's sphere object.
     */
    isSphere: boolean;
    /**
         * Check whether it's BaseModelObject3D type or inherit from it.
         * @example
         * let obj = new THING.BaseModelObject3D();
        let ret = obj.isBaseModelObject3D;
        // @expect(ret == true)
         */
    isBaseModelObject3D: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The spot light object in scene.
   * @param param - The initial parameters.
   */
  class SpotLight extends THING.BaseShadowLight {
    constructor(param: any);
    /**
     * Get/Set distance.
     */
    distance: number;
    /**
     * Get/Set angle.
     */
    angle: number;
    /**
     * Get/Set penumbra.
     */
    penumbra: number;
    /**
     * Get/Set decay.
     */
    decay: number;
    /**
     * Enable/Disable cast shadow.
     */
    castShadow: boolean;
    /**
     * Get/Set shadow quality.
     */
    shadowQuality: ShadowQualityType | number;
    /**
     * Get/Set shadow bias.
     */
    shadowBias: number;
    /**
     * Get/Set shadow range.
     */
    shadowRange: ShadowRangeInfo;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The water object in scene.
   * @param param - The initial parameters.
   */
  class Water extends THING.BasePlanePoints {
    constructor(param: any);
    /**
     * Get/Set flow speed.
     */
    flowSpeed: Number[];
    /**
     * Get/Set flow weight.
     */
    flowWeight: number;
    /**
     * Get/Set reflect distortion.
     */
    reflectDistortion: number;
    /**
     * Get/Set noise time scale.
     */
    noiseTimeScale: number;
    /**
     * Get/Set the holes in world space.
     */
    holes: Number[][][];
    /**
     * Get the area.
     */
    area: number;
    /**
     * Get the perimeter.
     */
    perimeter: number;
    /**
     * Get the label position in world space.
     */
    labelPosition: Number[];
    /**
     * Get the outline points in plane.
     */
    outlinePoints: Number[][];
    /**
         * Check whether it's BaseDynamicPoints type or inherit from it.
         * @example
         * let point = new THING.BaseDynamicPoints();
        let ret = point.isBaseDynamicPoints;
        // @expect(ret == true);
         */
    isBaseDynamicPoints: boolean;
    /**
         * Clear all points.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
        point.clearPoints();
        ret = point.points.length == 0;
        // @expect(ret == true);
         */
    clearPoints(): void;
    /**
         * Insert point by index in world space.
         * @example
         * let point = new THING.Points();
        point.addPoint([1,1,1]);
        point.insertPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    insertPoint(index: number, position: Number[]): void;
    /**
         * Add point in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoint([1,1,1]);
        ret = point.points.length == 1;
        // @expect(ret == true);
         * @param position - The world position.
         */
    addPoint(position: Number[]): void;
    /**
         * Add points in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points.length == 2;
        // @expect(ret == true);
         * @param points - The points in world space.
         */
    addPoints(points: Number[][]): void;
    /**
         * Remove point by index.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.removePoint(0);
        ret = point.points[0][0] == 2;
        // @expect(ret == true);
         * @param index - The index.
         */
    removePoint(index: number): void;
    /**
         * Set the point by index in world space.
         * @example
         * let point = new THING.Points();
        let ret = point.points.length == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.points[0][0] == 1;
        // @expect(ret == true);
        point.setPoint(0,[10,10,10]);
        ret = point.points[0][0] == 10;
        // @expect(ret == true);
         * @param index - The index.
         * @param position - The world position.
         */
    setPoint(index: number, position: Number[]): void;
    /**
         * Get the number of points.
         * @example
         * let point = new THING.Points();
        let ret = point.number == 0;
        // @expect(ret == true);
        point.addPoints([[1,1,1],[2,2,2]]);
        ret = point.number == 2;
        // @expect(ret == true);
         */
    number: number;
    /**
         * Get/Set the auto adjust position flag, default is false.
        If the relative position of point(s) is too large, there will be a problem of precision loss (object drawing will shake).
         * @example
         * let point = new THING.Points();
        let ret = point.autoAdjustPosition == false;
        // @expect(ret == true);
        point.autoAdjustPosition = true;
        ret = point.autoAdjustPosition == true;
        // @expect(ret == true);
         */
    autoAdjustPosition: boolean;
    /**
         * Get/Set the points in self space.
         * @example
         * let point = new THING.Points();
        point.selfPoints = [[1,1,1],[2,2,2]];
        ret = point.selfPoints[1][1] == 2;
        // @expect(ret == true);
         */
    selfPoints: Number[][];
    /**
         * Get/Set the points in world space.
         * @example
         * let point = new THING.Points();
        point.points = [[1,1,1],[2,2,2]];
        ret = point.points[1][1] == 2;
        // @expect(ret == true);
         */
    points: Number[][];
    /**
         * Get/Set the points in local space.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[1,1,1],[2,2,2]];
        ret = point.localPoints[1][1] == 2;
        // @expect(ret == true);
         */
    localPoints: Number[][];
    /**
         * Get the length of points.
         * @example
         * let point = new THING.Points();
        point.localPoints = [[0,0,0],[3,0,0],[0,4,0]];
        ret = point.length == 8;
        // @expect(ret == true);
         */
    length: number;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The web view object that can show it as renderable plane in scene.
   * @param param - The initial parameters.
   */
  class WebView extends THING.Object3D {
    constructor(param: any);
    /**
     * Get/Set the render type.
     */
    renderType: RenderType;
    /**
     * Get/Set url.
     */
    url: string;
    /**
     * Get/Set DOM width in pixel.
     */
    domWidth: number;
    /**
     * Get/Set DOM height in pixel.
     */
    domHeight: number;
    /**
         * Get/Set DOM scale(factor).
         * @example
         * // Keep ratio of size
            webView.domScale = 0.01;
            // Just set width and height without keeping ratio of size
            webView.domScale = [2, 3];
         */
    domScale: number | Number[];
    /**
     * Enable/Disable interactive.
     */
    interactive: boolean;
    /**
     * Get/Set name.
     * @example
     * object.name = 'MyObject';
     */
    public name: string;
    /**
         * Get/Set tags.
         * @example
         * // Get tags
            let tags = object.tags;
         console.log(tags);
        
         // Set tags by array
         object.tags = ['one','two','three'];
        
         // Set tags by set
         object.tags = new Set(['one','two','three']);
         */
    public tags: Set<String>;
    /**
         * Get/Set layer mask, it would use AND operator to test with camera's layer mask.
        If it's equals to 0 then indicates it can not render in this camera.
        The default value is 1.
        It CAN NOT work with instanced drawing mode for now.
         * @example
         * // Hide object by changing layer mask
        object.layerMask = 0;
         */
    public layerMask: number;
    /**
         * Get visible state.
         * @example
         * let visible = object.getVisible();
            if (visible) {
                console.log('object is showing');
            }
         */
    public getVisible(): boolean;
    /**
         * Set visible state.
         * @example
         * // Hide object self only, exclude all children
            object.setVisible(false, false);
        
            // Hide object(s) but exclude children what name equals to 'stone'
            object.setVisible(false, (obj) => {
                if (obj.name == 'stone') {
                    return false;
                }
            });
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - If it's boolean value type then means whether process it with all children.
         */
    public setVisible(
      value: boolean,
      recursive?: boolean | ProcessObjectCallback
    ): void;
    /**
         * Get the inherit.
         * @example
         * object.inherit.style = THING.InheritType.Jump;
            object.inherit.visible = THING.InheritType.Break;
            object.inherit.pickable = THING.InheritType.Stop;
         */
    public inherit: InheritData;
    /**
         * Get/Set visible state.
         * @example
         * let object = new THING.Box();
            // @expect(object.visible == true)
            object.visible = false;
            // @expect(object.visible == false)
         */
    public visible: boolean;
    /**
         * Get/Set the pickable state.
         * @example
         * let object = new THING.Box();
            object.pickable = false;
         */
    public pickable: boolean;
    /**
         * Get/Set active state, would not change any children active.
         * @example
         * let box = new THING.Box();
            let box2 = new THING.Box({parent: box});
            box.active = false;
            // @expect(box2.active == true);
            // @expect(box.active == false);
         */
    public active: boolean;
    /**
         * Get the distance to world position.
         * @example
         * let distance = object.distanceTo([0, 10, 0]);
            if (distance > 5000) {
                console.log('object is so far from specified position');
            }
         * @param target - The target object or world position.
         */
    public distanceTo(target: THING.Object3D | Number[]): number;
    /**
         * Keep object's size in screen(auto adjust object's scale).
         * @example
         * let keepSize = object.keepSize;
            if (keepSize) {
                console.log('object is keep size to render');
            }
         */
    public keepSize: boolean;
    /**
         * Get/Set pivot in self oriented box from [left, bottom, back].
         * @example
         * // Make object origin to [right, top, front] position
            object.pivot = [1, 1, 1];
         */
    public pivot: Number[];
    /**
         * Add object as child.
         * @example
         * // Keep local transform of box to be added to object
            object.add(new THING.Box({ localPosition: [0, 10, 0]}), { attachMode: false });
         * @param object - The object what you want to add.
         * @param options - The options.
         * @param options.subNodeName - The sub node name.
         * @param options.localPosition - The local position of parent or sub node.
         * @param [options.attachMode = true] - True indicates to keep world transform.
         * @param [options.ignoreScale = false] - True indicates ignore scale when add it as child.
         */
    public add(
      object: THING.BaseObject,
      options: {
        subNodeName: string;
        localPosition: Number[];
        attachMode?: boolean;
        ignoreScale?: boolean;
      }
    ): boolean;
    /**
         * Promote node as child object.
         * @example
         * // Promote all sub nodes
            var nodeNames = entity.body.nodeNames;
            nodeNames.forEach(name => {
                entity.promoteNode(name);
            });
         * @param name - The node name.
         * @param parent - The parent object, if it's null then indicates use current object as parent.
         */
    public promoteNode(name: string, parent: THING.Object3D): THING.Object3D;
    /**
         * Set style values.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            box1.setStyle({color: 'red'});
            // @expect(box1.style.color[0] == 1);
            // @expect(box1.style.color[1] == 0);
            // @expect(box1.style.color[2] == 0);
            // @expect(box2.style.color == null);
         * @param value - The style values.
         * @param [recursive = false] - True indicates to set all children style values.
         */
    public setStyle(value: any, recursive?: boolean): void;
    /**
         * Get/Set style.
         * @example
         * let style = object.style;
            style.color = 'red';
            style.opacity = 0.1;
         */
    public style: THING.Style;
    /**
         * Clone the object, if the clone target has been loaded, clone the node directly, otherwise use url clone.
         * @example
         * // Clone the object and move up
            let otherObject = object.clone();
            otherObject.translateY(10);
         * @param recursive - True indicates to load all children resources.
         * @param parent - The parent object, default is app root object.
         */
    public clone(recursive: boolean, parent: THING.BaseObject): THING.Object3D;
    /**
         * Wait for object load completed.
         * @example
         * // Wait for object load completed then watch it
            await object.waitForComplete();
            app.camera.fit(object);
         */
    public waitForComplete(): Promise<any>;
    /**
         * Load resource.
         * @example
         * // Wait the object to load resource completed
            await object.loadResource();
         * @param [recursive = true] - True indicates to load all children resources.
         * @param [options = {}] - The load options.
         */
    public loadResource(recursive?: boolean, options?: any): Promise<any>;
    /**
         * Unload resource.
         * @example
         * // Wait the object to unload resource completed
            await object.unloadResource();
         * @param [recursive = true] - True indicates to unload all children resources.
         */
    public unloadResource(recursive?: boolean): Promise<any>;
    /**
     * Get the body object.
     */
    public body: THING.BodyObject;
    /**
         * Copy from object (except UUID attribute and parent).
        It would reload resource.
         * @example
         * // Copy the object from query result
            let sourceObject = app.query('#master')[0];
            if (sourceObject) {
                object.copy(sourceObject);
            }
         * @param object - The source object.
         */
    public copy(object: THING.BaseObject): Promise<any>;
    /**
         * Enable/Disable always on top.
         * @example
         * // Keep object render as the top of render layer
        object.alwaysOnTop = true;
         */
    public alwaysOnTop: boolean;
    /**
         * Make object in instanced drawing mode.
         * @example
         * // Make object render in instanced drawing mode
            if (object.makeInstancedDrawing()) {
                console.log('Enable instanced drawing');
            }
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         * @param [options.renderMode = 'InstancedRendering'] - The render mode(could be 'SharedRendering/InstancedRendering').
         */
    public makeInstancedDrawing(
      value: boolean,
      options: {
        renderMode?: string;
      }
    ): boolean;
    /**
         * Get bounding box recursively.
         * @example
         * let boundingBox = object.boundingBox;
            if (boundingBox.halfSize[1] > 100) {
                console.log('The object is so tall');
            }
         */
    public boundingBox: THING.Box3;
    /**
         * Get oriented box recursively.
         * @example
         * let orientedBox = object.orientedBox;
            if (orientedBox.angles[1] > 0) {
                console.log('The object has rotated by Y-axis');
            }
         */
    public orientedBox: OrientedBoxResult;
    /**
     * Get the flying state.
     */
    public isFlying: boolean;
    /**
     * Stop moving.
     * @example
     * object.stopMoving();
     */
    public stopMoving(): void;
    /**
     * Pause moving.
     * @example
     * object.pauseMoving();
     */
    public pauseMoving(): void;
    /**
     * Resume moving.
     * @example
     * object.resumeMoving();
     */
    public resumeMoving(): void;
    /**
         * Move object in duration.
         * @example
         * object.moveTo(object.selfToWorld(THING.Math.randomVector([-200, -5, -200], [200, 5, 200])), {
                loopType: THING.LoopType.PingPong,
                duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The position.
         * @param param - The parameters.
         */
    public moveTo(value: Number[], param: MovePathLerpArgs): void;
    /**
         * Move object with path in duration.
         * @example
         * let path = [
            [100, 0, 0],
            [100, 0, 100],
            [0, 0, 100],
        [0, 0, 0],
        ];
        
        object.movePath(path.map(point => object.selfToWorld(point)), {
            duration: 5 * 1000,
            loopType: THING.LoopType.Repeat,
        });
         * @param value - The path of position.
         * @param param - The parameters.
         */
    public movePath(value: Number[][], param: MovePathLerpArgs): void;
    /**
     * Stop scaling.
     * @example
     * object.stopScaling();
     */
    public stopScaling(): void;
    /**
     * Pause scaling.
     * @example
     * object.pauseScaling();
     */
    public pauseScaling(): void;
    /**
     * Resume scaling.
     * @example
     * object.resumeScaling();
     */
    public resumeScaling(): void;
    /**
         * Scale object in duration.
         * @example
         * object.scaleTo(THING.Math.randomVector([1, 1, 1], [3, 3, 3]), {
            loopType: THING.LoopType.PingPong,
            duration: THING.Math.randomInt(1000, 5000)
        });
         * @param value - The scale.
         * @param param - The parameters.
         */
    public scaleTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Stop rotating.
     * @example
     * object.stopRotating();
     */
    public stopRotating(): void;
    /**
     * Pause rotating.
     * @example
     * object.pauseRotating();
     */
    public pauseRotating(): void;
    /**
     * Resume rotating.
     * @example
     * object.resumeRotating();
     */
    public resumeRotating(): void;
    /**
         * Rotate object in duration.
         * @example
         * object.rotateTo([0, 360, 0], {
            loopType: THING.LoopType.Repeat,
            duration: 10 * 1000
        });
         * @param value - The angles.
         * @param param - The parameters.
         */
    public rotateTo(value: Number[], param: LerpWithSpaceTypeArgs): void;
    /**
     * Fade object in.
     * @param param - The parameters.
     */
    public fadeIn(param: LerpArgs): void;
    /**
     * Fade object out.
     * @param param - The parameters.
     */
    public fadeOut(param: LerpArgs): void;
    /**
     * Stop flying.
     * @example
     * object.stopFlying();
     */
    public stopFlying(): void;
    /**
     * Pause flying.
     * @example
     * object.pauseFlying();
     */
    public pauseFlying(): void;
    /**
     * Resume flying.
     * @example
     * object.resumeFlying();
     */
    public resumeFlying(): void;
    /**
         * Fly to specified position in duration.
         * @example
         * object.flyTo({
                target: otherTarget,
                horzAngle: 0,
                vertAngle: 45
            });
         * @param param - The object or parameters.
         */
    public flyTo(param: THING.BaseObject | LerpFlyToArgs): void;
    /**
     * Auto set it to best position of object.
     * @example
     * THING.App.current.camera.fit(otherTarget);
     * @param param - The parameters.
     * @param param.target - The target object.
     */
    public fit(param: { target: THING.BaseObject }): void;
    /**
     * Stop UV transform.
     * @example
     * object.stopUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public stopUVTransform(slotType: ImageSlotType): void;
    /**
     * Pause UV transform.
     * @example
     * object.pauseUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public pauseUVTransform(slotType: ImageSlotType): void;
    /**
     * Resume UV transform.
     * @example
     * object.resumeUVTransform(THING.ImageSlotType.Map);
     * @param slotType - The slot type of style.
     */
    public resumeUVTransform(slotType: ImageSlotType): void;
    /**
         * Start UV transform in duration.
         * @example
         * // Lerp UV offset from [0, 0] to [-1, 0] in 2 seconds by repeat mode
        object.uvTransformTo(THING.ImageSlotType.Map, {
            from: { offset: [0, 0] },
            to: { offset: [-1, 0] },
            duration: 2000,
            loopType: THING.LoopType.Repeat,
            times: 3
        });
         * @param slotType - The slot type of style.
         * @param value - The UV transform info.
         * @param param? - The parameters.
         */
    public uvTransformTo(
      slotType: ImageSlotType,
      value: StyleUVMatrixResult | LerpArgs,
      param?: LerpArgs
    ): void;
    /**
     * Get/Set local(offset) position of the parent space.
     */
    public localPosition: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localAngles: Number[];
    /**
     * Get/Set angles of the inertial space.
     */
    public localRotation: Number[];
    /**
     * Get/Set quaternion of the inertial space.
     */
    public localQuaternion: Number[];
    /**
     * Get/Set scale of the self coordinate system.
     */
    public localScale: Number[];
    /**
     * Get/Set world position of the world space.
     */
    public position: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public angles: Number[];
    /**
     * Get/Set angles of the world space.
     */
    public rotation: Number[];
    /**
     * Get/Set quaternion of the world space.
     */
    public quaternion: Number[];
    /**
     * Get/Set scale of the world coordinate system.
     */
    public scale: Number[];
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotate(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotate(axis: Number[], angle: number): void;
    /**
         * Rotate on axis by angle in self space.
         * @example
         * let box = new THING.Box();
            box.rotateOnAxis(THING.Utils.xAxis, 45);
            
         * @param axis - The axis in self space.
         * @param angle - The degree.
         */
    public rotateOnAxis(axis: Number[], angle: number): void;
    /**
     * Rotate on x-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateX(angle: number): void;
    /**
     * Rotate on y-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateY(angle: number): void;
    /**
     * Rotate on z-axis in self coordinates.
     * @param angle - The angle.
     */
    public rotateZ(angle: number): void;
    /**
     * Translate on x-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateX(distance: number): void;
    /**
     * Translate on y-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateY(distance: number): void;
    /**
     * Translate on z-axis in self coordinates.
     * @param distance - The distance.
     */
    public translateZ(distance: number): void;
    /**
     * Translate in self coordinates.
     * @param offset - The offset.
     */
    public translate(offset: Number[]): void;
    /**
     * Look at object or position.
     * @param target - The target what to look at.
     * @param param - The parameters.
     */
    public lookAt(target: Number[] | THING.Object3D, param: LookAtArgs): void;
    /**
     * Convert world position to self position.
     * @param position - The world position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public worldToSelf(position: Number[], ignoreScale?: boolean): Number[];
    /**
     * Convert self position to world position.
     * @param position - The self position.
     * @param [ignoreScale = false] - True indicates ignore scale factor.
     */
    public selfToWorld(position: Number[], ignoreScale?: boolean): Number[];
    /**
         * Check whether has attribute.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let ret = object.hasAttribute('userData/power');
        // @expect(ret == true)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public hasAttribute(name: string): boolean;
    /**
         * Get attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.userData['power'] = 100;
        let power = object.getAttribute('userData/power');
        // @expect(power == 100)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         */
    public getAttribute(name: string): any;
    /**
         * Set attribute value.
         * @example
         * let object = new THING.BaseObject();
        object.setAttribute('userData/power', 200);
        let power = object.getAttribute('userData/power');
        // @expect(power == 200)
         * @param name - The attribute name, it can use like 'a/b/c' to access attribute.
         * @param value - The attribute value.
         */
    public setAttribute(name: string, value: any): void;
    /**
         * Set attribute values.
         * @example
         * let object = new THING.BaseObject();
        object.setAttributes({
          "userData/name": 'Mr.Door',
          "userData/age": 18
        })
        let name = object.getAttribute('userData/name');
        // @expect(name == 'Mr.Door')
        let age = object.getAttribute('userData/age');
        // @expect(age == 18)
         * @param attributes - The attribute values.
         * @param [overwrite = true] - True indicates overwrite attribute.
         */
    public setAttributes(attributes: any, overwrite?: boolean): void;
    /**
         * Get application.
         * @example
         * let object = new THING.BaseObject();
        let app = object.app;
        let ret = app == THING.App.current;
        // @expect(ret == true)
         */
    public app: THING.App;
    /**
         * Get type.
         * @example
         * let object = new THING.BaseObject();
        let type = object.type;
        // @expect(type == 'BaseObject')
         */
    public type: string;
    /**
         * Get/Set id.
         * @example
         * let object = new THING.BaseObject();
        object.id = 'DEVICE_007';
        // @expect(object.id == 'DEVICE_007')
         */
    public id: string;
    /**
         * Get/Set uuid.
         * @example
         * let object = new THING.BaseObject({uuid: 10000});
        // @expect(object.uuid == 10000)
        object.uuid = THING.Math.generateUUID();
        // @expect(object.id != 10000)
         */
    public uuid: string;
    /**
         * Get/Set user data.
         * @example
         * let object = new THING.BaseObject();
        object.userData['Notebook'] = {
            name: 'FlyingCar',
            price: 100
        };
        let name = object.userData['Notebook'].name;
        // @expect(name == 'FlyingCar')
        let price = object.userData['Notebook'].price
        // @expect(price == 100)
         */
    public userData: any;
    /**
         * Destroy.
         * @example
         * let object = new THING.BaseObject();
        // @expect(object.destroyed == false);
        object.destroy();
        // @expect(object.destroyed == true)
         */
    public destroy(): boolean;
    /**
         * Enable/Disable queryable.
         * @example
         * let object = new THING.BaseObject();
        object.name = 'Hidden';
        let ret = app.query('Hidden');
        // @expect(ret[0].name = 'Hidden')
        object.queryable = false;
        ret = app.query('Hidden');
        // @expect(ret.length = 0)
         */
    public queryable: boolean;
    /**
         * Register event.
         * @example
         * let object = new THING.BaseObject();
        let mark = 0;
        object.on('click', function(ev){
            mark = 1;
        }, 'MyClick');
        object.trigger('click');
        // @expect(mark == 1)
        let mark2 = 0;
        object.on('click', '.Box', function(ev){
            mark2 = 1;
        }, 'MyClick');
        // @expect(mark2 == 0)
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first).
         * @param options - The options.
         */
    public on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register event what just trigger once time.
         * @example
         * let object = new THING.BaseObject();
        let markOnce = 0;
        object.once('testOnce', function(ev) {
                markOnce = 1;
        });
        object.trigger('testOnce');
        // @expect(markOnce == 1);
        markOnce = 0;
        object.trigger('testOnce');
        // @expect(markOnce == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param callback? - The callback function.
         * @param tag? - The event tag.
         * @param priority? - The priority value(default is 0, higher value will be processed first).
         * @param options? - The options.
         */
    public once(
      type: string,
      condition?: string,
      callback?: (...params: any[]) => any,
      tag?: string,
      priority?: number,
      options?: ObjectEventOptions
    ): void;
    /**
         * Unregister event.
         * @example
         * let object = new THING.BaseObject();
        let markOff = 0;
        object.on('testOff', function(ev) {
                markOff = 1;
        });
        object.trigger('testOff');
        // @expect(markOff == 1);
        markOff = 0;
        object.off('testOff');
        object.trigger('testOff');
        // @expect(markOff == 0);
         * @param type - The event type.
         * @param condition? - The condition to select objects.
         * @param tag - The event tag.
         */
    public off(type: string, condition?: string, tag: string): void;
    /**
         * Pause event.
         * @example
         * let object = new THING.BaseObject();
        let markPause = 0;
        object.on('testPause', function(ev) {
                markPause = 1;
        });
        object.trigger('testPause');
        // @expect(markPause == 1);
        markPause = 0;
        object.pauseEvent('testPause');
        object.trigger('testPause');
        // @expect(markPause == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume event.
         * @example
         * let object = new THING.BaseObject();
        let markResume = 0;
        object.on('testResume', function(ev) {
                markResume = 1;
        });
        object.trigger('testResume');
        // @expect(markResume == 1);
        markResume = 0;
        object.pauseEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 0);
        object.resumeEvent('testResume');
        object.trigger('testResume');
        // @expect(markResume == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    public resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger event.
         * @example
         * let object = new THING.BaseObject();
         let markTrigger = {};
            object.on('myEvent', function(ev) {
                markTrigger = ev;
            });
            object.trigger('myEvent', { result: true });
         let ret = markTrigger.result;
         // @expect(ret == true);
         * @param type - The event type.
         * @param ev - The event info.
         * @param options? - The options.
         * @param options.tag - The tag name.
         */
    public trigger(type: string, ev: any, options?: any): any;
    /**
         * Check whether it's child.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject({parent: parent});
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isChildOf(object: THING.BaseObject): boolean;
    /**
         * Check whether it's brother.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let ret = child1.isBrotherOf(child2);
         // @expect(ret == true);
         * @param object - The object to check.
         */
    isBrotherOf(object: THING.BaseObject): boolean;
    /**
         * Remove child object.
         * @example
         * let parent = new THING.BaseObject();
        let child = new THING.BaseObject();
        parent.add(child);
        let ret = child.isChildOf(parent);
         // @expect(ret == true);
            parent.remove(child);
        ret = child.isChildOf(parent);
            // @expect(ret == false);
         * @param object - The object what you want to remove.
         */
    public remove(object: THING.BaseObject): boolean;
    /**
         * Traverse self and all children.
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverse((child) => {
                mark++;
        });
        // @expect(mark == 3)
         * @param callback - The callback function.
         */
    public traverse(callback: (...params: any[]) => any): void;
    /**
         * Traverse self and all children. (Support for exit at traverse runtime)
         * @example
         * let parent = new THING.BaseObject();
        let child1 = new THING.BaseObject({parent: parent});
        let child2 = new THING.BaseObject({parent: parent});
        let mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
        });
        // @expect(mark == 3)
        mark = 0;
        parent.traverseBranch((child)=>{
               mark++;
            if(child.children.length > 0){
                   return false;
               }
               return true;
        });
        // @expect(mark == 1)
         * @param callback - The callback function. (Return false to exit)
         */
    traverseBranch(callback: (...params: any[]) => any): void;
    /**
         * Check whether has any children.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = parent.hasChildren();
            // @expect(ret == true);
         */
    hasChildren(): boolean;
    /**
         * Get/Set parent.
         * @example
         * let parent = new THING.BaseObject();
         let child = new THING.BaseObject({parent: parent});
            let ret = child.parent == parent;
            // @expect(ret == true);
         */
    public parent: THING.BaseObject;
    /**
         * Get/Set relationships.
         * @example
         * let object = new THING.Object3D();
        let source = new THING.Object3D();
        let target = new THING.Object3D();
        let relationship = new THING.Relationship({
             type: 'control',
             source: source,
             target: target
        });
        object.addRelationship(relationship);
        let ret = object.relationships[0].type == 'control';
        // @expect(ret == true)
         */
    public relationships: THING.Relationship[];
    /**
         * Get the parents.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let parents = box2.parents;
         // @expect(parents.length == 2);
         */
    public parents: THING.Selector;
    /**
         * Get the brothers.
         * @example
         * let box1 = new THING.Box();
            let box2 = new THING.Box({parent: box1});
            let box3 = new THING.Box({parent: box1});
            let brothers = box3.brothers;
         // @expect(brothers.length == 1);
         */
    public brothers: THING.Selector;
    /**
         * Get children.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        let children = object.children;
        let ret = children.length == 1;
        // @expect(ret == true)
         */
    public children: THING.Selector;
    /**
         * Query children by condition.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object});
        child.userData = {power: 1000};
        let children = object.children.query('[userData/power>100]');
        let ret = children.length == 1;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options? - The options.
         */
    public query(
      condition: string,
      options?: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let object = new THING.BaseObject();
        let child= new THING.BaseObject({parent: object, name: 'liming'});
        let result = object.queryByName('liming');
        let ret = result[0].name == 'liming';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByName(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, name: 'car1'});
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByRegExp(/car/);
        let ret = result.length == 2;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByRegExp(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Object3D({parent: object, name: 'car1'});
        child1.tags.add('testCar');
        let child2= new THING.BaseObject({parent: object, name: 'car2'});
        let result = object.queryByTags('testCar');
        let ret = result.length == 1;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByTags(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object, uuid: '1000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUUID('1000');
        let ret = result[0].uuid == '1000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUUID(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.BaseObject({parent: object});
        child1.id = '10000';
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryById('10000');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryById(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object, id: '10000'});
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByType('Box');
        let ret = result[0].id == '10000';
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByType(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let object = new THING.BaseObject();
        let child1= new THING.Box({parent: object});
        child1.userData['power'] = 100;
        let child2= new THING.BaseObject({parent: object});
        let result = object.queryByUserData('power=100');
        let ret = result[0].userData.power == 100;
         //@expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    public queryByUserData(
      condition: string,
      options: ObjectQueryOptions
    ): THING.Selector;
    /**
         * Add component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        // @expect(obj.myComponent != null)
         * @param component - The component class or component object.
         * @param name - The name.
         * @param args? - The initial arguments to create component.
         */
    addComponent(
      component: THING.BaseComponent | any,
      name: string,
      args?: any
    ): boolean;
    /**
         * Remove component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        obj.removeComponent('myComponent');
        // @expect(obj.components.size == 0)
         * @param name - The name.
         */
    removeComponent(name: string): void;
    /**
         * Remove all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        obj.removeAllComponents();
        // @expect(obj.components.size == 0)
         */
    removeAllComponents(): void;
    /**
         * Traverse component by type.
         * @example
         * object.addComponent(new MyComponent(), 'myComponent');
            object.traverseComponentByType(MyComponent, (component, name) => {
                console.log(component, name);
            });
         * @param type - The component type.
         * @param callback - The callback function.
         */
    traverseComponentByType(
      type: any,
      callback: TraverseComponentByTypeCallback
    ): void;
    /**
         * Get component by name.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByName('myComponent');
        // @expect(component != null)
         * @param name - The name.
         */
    getComponentByName(name: string): THING.BaseComponent;
    /**
         * Get component by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let component = obj.getComponentByType(THING.BaseComponent);
        // @expect(component != null)
         * @param type - The component type.
         */
    getComponentByType(type: any): THING.BaseComponent;
    /**
         * Get components by type.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getComponentsByType(THING.BaseComponent);
        // @expect(components.length == 2)
         * @param type - The component type.
         */
    getComponentsByType(type: any): THING.BaseComponent[];
    /**
         * Get all components(it would create all registered components).
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        let components = obj.getAllComponents();
        // @expect(components.length == 2)
         */
    getAllComponents(): THING.BaseComponent[];
    /**
         * Check whether has component.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'myComponent');
        let ret = obj.hasComponent('myComponent')
        // @expect(ret == true)
         * @param name - The name.
         */
    hasComponent(name: string): boolean;
    /**
         * Get all components.
         * @example
         * let obj = new THING.BaseObject();;
        obj.addComponent(new THING.BaseComponent(), 'component1');
        obj.addComponent(new THING.BaseComponent(), 'component2');
        // @expect(obj.components.size == 2)
         */
    readonly components: Map<String, THING.BaseComponent>;
  }
  /**
   * The parser of objects scene in layout mode.
   */
  class SceneLayoutParser {}
  /**
   * The parser of objects scene in tree mode.
   */
  class SceneObjectParser {}
  /**
   * The relationship between objects.
   * @param param.type - The relationship type.
   * @param param.name - The relationship name.
   * @param param.source - The source object(s) of relation.
   * @param param.target - The target object(s) of relation.
   * @param [param.queryDirection] - The default query relationship direction.
   */
  class Relationship {
    constructor(param: {
      type: string;
      name: string;
      source: THING.BaseObject | THING.BaseObject[] | THING.Selector;
      target: THING.BaseObject | THING.BaseObject[] | THING.Selector;
      queryDirection?: string;
    });
    /**
         * destroy relationship
         * @example
         * let rel = app.queryRelationships({type: "control"})[0];
        rel.destroy();
         */
    public destroy(): void;
    /**
     * Get/Set the relationship type.
     */
    public type: string;
    /**
     * Get/Set the relationship name.
     */
    public name: string;
    /**
         * Get/Set uuid.
         * @example
         * relationship.uuid = THING.Math.generateUUID();
        console.log(object.uuid);
         */
    uuid: string;
    /**
     * Get/Set the relationship source object.
     */
    public source: THING.BaseObject | THING.BaseObject[] | THING.Selector;
    /**
     * Get/Set the relationship target.
     */
    public target: THING.BaseObject | THING.BaseObject[] | THING.Selector;
    /**
     * Get/Set the relationship default query direction.
     */
    public queryDirection: RelationshipDirection;
  }
  /**
   * The renderer to draw on canvas.
   * @param param - The initial parameters.
   */
  class CanvasRenderer {
    constructor(param: any);
    /**
         * Render from the html text.
         * @param html - The string of DOM Node object to render.
         * @param options - Rendering options
         * @param options.bgcolor - color for the background, any valid CSS color value.
         * @param options.filter - Should return true if passed node should be included in the output
                 (excluding node means excluding it's children as well). Not called on the root node.
         * @returns A promise that is fulfilled with a canvas object.
         */
    renderFromHTML(
      html: string,
      options: {
        bgcolor: string;
        filter: (...params: any[]) => any;
      }
    ): Promise;
  }
  /**
   * The image texture that load image resource and use by style.
   * @param param - The initial parameters.
   */
  class BaseImageTexture extends THING.BaseTexture {
    constructor(param: any);
    /**
     * Get/Set url.
     */
    url: string;
    /**
     * Get/Set the color format.
     */
    colorFormat: number;
    /**
     * Get/Set the anisotropy.
     */
    anisotropy: number;
    /**
     * Get/Set the wrapping behavior for the S texture coordinate.
     */
    wrapTypeS: ImageWrapType;
    /**
     * Get/Set the wrapping behavior for the T texture coordinate.
     */
    wrapTypeT: ImageWrapType;
    /**
     * Get/Set the wrapping behavior for the both S and T texture coordinates.
     */
    wrapType: ImageWrapType;
    /**
     * Get/Set the mappingType type.
     */
    mappingType: ImageMappingType;
    /**
     * Get/Set the min filter type.
     */
    minFilterType: ImageFilterType;
    /**
     * Get/Set the mag filter type.
     */
    magFilterType: ImageFilterType;
    /**
     * Enable/Disable flipY.
     */
    flipY: boolean;
    /**
     * Enable/Disable premultiply alpha.
     */
    premultiplyAlpha: boolean;
    /**
     * Enable/Disable generate mipmaps.
     */
    generateMipmaps: boolean;
    /**
     * Wait for object load completed.
     */
    waitForComplete(): Promise<any>;
    /**
     * Get the unique ID.
     */
    uuid: string;
    /**
     * Get the loaded flag.
     */
    loaded: boolean;
  }
  /**
     * BaseResource
    The base resource.
     */
  class BaseResource {
    /**
     * Wait for object load completed.
     */
    waitForComplete(): Promise<any>;
    /**
     * Get the unique ID.
     */
    uuid: string;
    /**
     * Get the loaded flag.
     */
    loaded: boolean;
  }
  /**
   * The base static texture means we can not change any attributes of it in runtime(only use the initial attributes).
   * @param param - The initial parameters.
   */
  class BaseStaticTexture {
    constructor(param: any);
    /**
     * Get the color format.
     */
    colorFormat: number;
    /**
     * Get the anisotropy.
     */
    anisotropy: number;
    /**
     * Get the wrap type.
     */
    wrapType: ImageWrapType;
    /**
     * Get the mappingType type.
     */
    mappingType: ImageMappingType;
    /**
     * Get the min filter type.
     */
    minFilterType: ImageFilterType;
    /**
     * Get the mag filter type.
     */
    magFilterType: ImageFilterType;
    /**
     * Get flipY.
     */
    flipY: boolean;
    /**
     * Get premultiply alpha.
     */
    premultiplyAlpha: boolean;
    /**
     * Check generate mipmaps.
     */
    generateMipmaps: boolean;
    /**
     * Check class type.
     */
    isBaseStaticTexture: boolean;
  }
  /**
     * BaseTexture
    The base texture resource.
     */
  class BaseTexture extends THING.BaseResource {
    /**
     * Copy texture.
     * @param source - The texture.
     */
    copy(source: THING.BaseTexture): THING.BaseTexture;
    /**
     * Get/Set the color format.
     */
    colorFormat: number;
    /**
     * Get/Set the anisotropy.
     */
    anisotropy: number;
    /**
     * Get/Set the wrapping behavior for the S texture coordinate.
     */
    wrapTypeS: ImageWrapType;
    /**
     * Get/Set the wrapping behavior for the T texture coordinate.
     */
    wrapTypeT: ImageWrapType;
    /**
     * Get/Set the wrapping behavior for the both S and T texture coordinates.
     */
    wrapType: ImageWrapType;
    /**
     * Get/Set the mappingType type.
     */
    mappingType: ImageMappingType;
    /**
     * Get/Set the min filter type.
     */
    minFilterType: ImageFilterType;
    /**
     * Get/Set the mag filter type.
     */
    magFilterType: ImageFilterType;
    /**
     * Enable/Disable flipY.
     */
    flipY: boolean;
    /**
     * Enable/Disable premultiply alpha.
     */
    premultiplyAlpha: boolean;
    /**
     * Enable/Disable generate mipmaps.
     */
    generateMipmaps: boolean;
    /**
     * Wait for object load completed.
     */
    waitForComplete(): Promise<any>;
    /**
     * Get the unique ID.
     */
    uuid: string;
    /**
     * Get the loaded flag.
     */
    loaded: boolean;
  }
  /**
     * The cube texture that load image resource and use by style.
     * @example
     * // Create cube texture from cube map images
    let cubeTexture = new THING.CubeTexture([
        './skyboxes/bluesky/posx.jpg', './skyboxes/bluesky/negx.jpg',
        './skyboxes/bluesky/posy.jpg', './skyboxes/bluesky/negy.jpg',
        './skyboxes/bluesky/posz.jpg', './skyboxes/bluesky/negz.jpg'
    ]);
    
    // Create cube texture
    let cubeTexture = new THING.CubeTexture({
        url:{
            negx: './images/Night/negx.jpg', // 
            negy: './images/Night/negy.jpg', // 
            negz: './images/Night/negz.jpg', // 
            posx: './images/Night/posx.jpg', // 
            posy: './images/Night/posy.jpg', // 
            posz: './images/Night/posz.jpg'  // 
        }
    });
    
    // Create cube texture from folder path
    let cubeTexture = new THING.CubeTexture({
        url: './images/Night/'
    }};
     * @param param - The initial parameters.
     */
  class CubeTexture extends THING.BaseImageTexture {
    constructor(param: any);
    /**
         * Check class type.
         * @example
         * if (texture.isCubeTexture) {
                console.log(`It's cube texture`);
            }
         */
    isCubeTexture: boolean;
    /**
     * Get/Set url.
     */
    url: string;
    /**
     * Get/Set the color format.
     */
    colorFormat: number;
    /**
     * Get/Set the anisotropy.
     */
    anisotropy: number;
    /**
     * Get/Set the wrapping behavior for the S texture coordinate.
     */
    wrapTypeS: ImageWrapType;
    /**
     * Get/Set the wrapping behavior for the T texture coordinate.
     */
    wrapTypeT: ImageWrapType;
    /**
     * Get/Set the wrapping behavior for the both S and T texture coordinates.
     */
    wrapType: ImageWrapType;
    /**
     * Get/Set the mappingType type.
     */
    mappingType: ImageMappingType;
    /**
     * Get/Set the min filter type.
     */
    minFilterType: ImageFilterType;
    /**
     * Get/Set the mag filter type.
     */
    magFilterType: ImageFilterType;
    /**
     * Enable/Disable flipY.
     */
    flipY: boolean;
    /**
     * Enable/Disable premultiply alpha.
     */
    premultiplyAlpha: boolean;
    /**
     * Enable/Disable generate mipmaps.
     */
    generateMipmaps: boolean;
    /**
     * Wait for object load completed.
     */
    waitForComplete(): Promise<any>;
    /**
     * Get the unique ID.
     */
    uuid: string;
    /**
     * Get the loaded flag.
     */
    loaded: boolean;
  }
  /**
     * EmptyTexture
    The empty texture resource.
     */
  class EmptyTexture extends THING.BaseTexture {
    /**
     * Check class type.
     */
    isEmptyTexture: boolean;
    /**
     * Copy texture.
     * @param source - The texture.
     */
    copy(source: THING.BaseTexture): THING.BaseTexture;
    /**
     * Get/Set the color format.
     */
    colorFormat: number;
    /**
     * Get/Set the anisotropy.
     */
    anisotropy: number;
    /**
     * Get/Set the wrapping behavior for the S texture coordinate.
     */
    wrapTypeS: ImageWrapType;
    /**
     * Get/Set the wrapping behavior for the T texture coordinate.
     */
    wrapTypeT: ImageWrapType;
    /**
     * Get/Set the wrapping behavior for the both S and T texture coordinates.
     */
    wrapType: ImageWrapType;
    /**
     * Get/Set the mappingType type.
     */
    mappingType: ImageMappingType;
    /**
     * Get/Set the min filter type.
     */
    minFilterType: ImageFilterType;
    /**
     * Get/Set the mag filter type.
     */
    magFilterType: ImageFilterType;
    /**
     * Enable/Disable flipY.
     */
    flipY: boolean;
    /**
     * Enable/Disable premultiply alpha.
     */
    premultiplyAlpha: boolean;
    /**
     * Enable/Disable generate mipmaps.
     */
    generateMipmaps: boolean;
    /**
     * Wait for object load completed.
     */
    waitForComplete(): Promise<any>;
    /**
     * Get the unique ID.
     */
    uuid: string;
    /**
     * Get the loaded flag.
     */
    loaded: boolean;
  }
  /**
   * The geometry resource to build custom geometry info in scene.
   * @param param - The initial parameters.
   */
  class GeometryResource {
    constructor(param: any);
    /**
     * Get vertex data.
     */
    vertexData: any;
    /**
     * Get resource.
     */
    resource: any;
    /**
     * Get/Set position.
     */
    position: Number[];
    /**
     * Set uv.
     */
    uv: Number[];
    /**
     * Set normal.
     */
    normal: Number[];
  }
  /**
     * The image texture that load image resource and use by style.
     * @example
     * // Create image texture from pixel buffer with size
    let imageTexture = new THING.ImageTexture({
        data: pixelBuffer,
        width: 128,
        height: 128
    });
    
    // Create image texture from canvas
    let imageTexture = new THING.ImageTexture({
        resource: canvas
    });
     * @param param - The initial parameters.
     */
  class ImageTexture extends THING.BaseImageTexture {
    constructor(param: any | PixelBuffer | CanvasResource);
    /**
     * Get source url or base64 data.
     */
    src: string;
    /**
     * Get width in pixel.
     */
    width: number;
    /**
     * Get height in pixel.
     */
    height: number;
    /**
     * Enable/Disable flipY.
     */
    flipY: boolean;
    /**
         * Enable/Disable generate mipmaps.
        The minFilterType property will auto set to THING.ImageFilterType.LinearMipmapLinearFilter when generate mipmaps is enabled.
         */
    generateMipmaps: boolean;
    /**
     * Check class type.
     */
    isImageTexture: boolean;
    /**
     * Get/Set url.
     */
    url: string;
    /**
     * Get/Set the color format.
     */
    colorFormat: number;
    /**
     * Get/Set the anisotropy.
     */
    anisotropy: number;
    /**
     * Get/Set the wrapping behavior for the S texture coordinate.
     */
    wrapTypeS: ImageWrapType;
    /**
     * Get/Set the wrapping behavior for the T texture coordinate.
     */
    wrapTypeT: ImageWrapType;
    /**
     * Get/Set the wrapping behavior for the both S and T texture coordinates.
     */
    wrapType: ImageWrapType;
    /**
     * Get/Set the mappingType type.
     */
    mappingType: ImageMappingType;
    /**
     * Get/Set the min filter type.
     */
    minFilterType: ImageFilterType;
    /**
     * Get/Set the mag filter type.
     */
    magFilterType: ImageFilterType;
    /**
     * Enable/Disable premultiply alpha.
     */
    premultiplyAlpha: boolean;
    /**
     * Wait for object load completed.
     */
    waitForComplete(): Promise<any>;
    /**
     * Get the unique ID.
     */
    uuid: string;
    /**
     * Get the loaded flag.
     */
    loaded: boolean;
  }
  /**
   * The material resource to build custom geometry info in scene.
   * @param param - The initial parameters.
   */
  class MaterialResource extends THING.BaseResource {
    constructor(param: any);
    /**
     * Get the data.
     */
    data: any;
    /**
     * Wait for object load completed.
     */
    waitForComplete(): Promise<any>;
    /**
     * Get the unique ID.
     */
    uuid: string;
    /**
     * Get the loaded flag.
     */
    loaded: boolean;
  }
  /**
     * RenderTexture
    The render texture resource.
     */
  class RenderTexture extends THING.BaseStaticTexture {
    /**
     * Copy from image.
     * @param source - The image.
     */
    copy(source: THING.RenderTexture): THING.RenderTexture;
    /**
     * Clone image.
     */
    clone(): THING.RenderTexture;
    /**
     * Download file as image resource in PNG file format.
     * @example
     * renderTexture.download('myScreenshot');
     * @param fileName - The file name.
     */
    download(fileName: string): void;
    /**
     * Get/Set size.
     */
    size: Number[];
    /**
     * Get pixel buffer in RGBA color format.
     */
    pixelBuffer: Uint8Array;
    /**
     * Check class type.
     */
    isRenderTexture: boolean;
    /**
     * Get the color format.
     */
    colorFormat: number;
    /**
     * Get the anisotropy.
     */
    anisotropy: number;
    /**
     * Get the wrap type.
     */
    wrapType: ImageWrapType;
    /**
     * Get the mappingType type.
     */
    mappingType: ImageMappingType;
    /**
     * Get the min filter type.
     */
    minFilterType: ImageFilterType;
    /**
     * Get the mag filter type.
     */
    magFilterType: ImageFilterType;
    /**
     * Get flipY.
     */
    flipY: boolean;
    /**
     * Get premultiply alpha.
     */
    premultiplyAlpha: boolean;
    /**
     * Check generate mipmaps.
     */
    generateMipmaps: boolean;
    /**
     * Check class type.
     */
    isBaseStaticTexture: boolean;
  }
  /**
   * The object style, it can change object's color, outlineColor etc.
   * @param modifier - The modifier.
   */
  class Style {
    constructor(modifier: any);
    /**
     * Begin to set default values.
     */
    beginDefaultValues(): void;
    /**
     * End to set default values.
     */
    endDefaultValues(): void;
    /**
     * Get/Set the blending type.
     */
    blendingType: BlendingType;
    /**
     * Get/Set the side type.
     */
    sideType: SideType;
    /**
     * Enable/Disable transparent mode.
     */
    transparent: boolean;
    /**
     * Enable/Disable wireframe.
     */
    wireframe: boolean;
    /**
     * Enable/Disable depth test.
     */
    depthTest: boolean;
    /**
     * Enable/Disable depth write.
     */
    depthWrite: boolean;
    /**
     * Enable/Disable the env mapping.
     */
    envMapping: boolean;
    /**
     * Get/Set the current image slot type.
     */
    imageSlotType: ImageSlotType;
    /**
     * Get/Set the (canvas/image/url) image resource.
     */
    image: any;
    /**
     * Get/Set the image resource of map.
     */
    map: THING.ImageTexture;
    /**
     * Get/Set the image resource of env map.
     */
    envMap: THING.ImageTexture;
    /**
     * Get/Set the image resource of alpha map.
     */
    alphaMap: THING.ImageTexture;
    /**
     * Get/Set the image resource of emissive map.
     */
    emissiveMap: THING.ImageTexture;
    /**
     * Get/Set the image resource of normal map.
     */
    normalMap: THING.ImageTexture;
    /**
     * Get/Set the image resource of color mapping.
     */
    colorMapping: THING.ImageTexture;
    /**
     * Get/Set the image resource of ao map.
     */
    aoMap: THING.ImageTexture;
    /**
     * Get/Set the uv(matrix).
     */
    uv: StyleUVMatrixResult;
    /**
     * Get/Set the opacity.
     */
    opacity: number | StyleValueOperationCallback;
    /**
     * Get/Set the color.
     */
    color: number | string | Number[] | StyleColorOperationCallback;
    /**
     * Get/Set the metalness.
     */
    metalness: number | StyleValueOperationCallback;
    /**
     * Get/Set the roughness.
     */
    roughness: number | StyleValueOperationCallback;
    /**
     * Get/Set the emissive.
     */
    emissive: number | string | Number[] | StyleColorOperationCallback;
    /**
     * Get/Set the outline color.
     */
    outlineColor: number | string | Number[];
    /**
         * Get/Set the clipping planes.
         * @example
         * let clippingPlanes = [
            { direction: [0, -1, 0], height: 10 }, // top
            { direction: [0, 1, 0], height: 10 }, // bottom
            { direction: [-1, 0, 0], height: 10 }, // right
            { direction: [1, 0, 0], height: 10 }, // left
            { direction: [0, 0, -1], height: 10 }, // front
            { direction: [0, 0, 1], height: 10 } // back
        ];
        
        let clippingPlanesObject = new THING.ClippingPlanes({
            parent: object,
            planes: clippingPlanes,
        });
        
        object.query('*', { includeSelf: true }).style.clippingPlanes = clippingPlanesObject;
         */
    clippingPlanes: THING.ClippingPlanes[];
    /**
     * Get/Set the edge.
     */
    edge: StyleEdgeResult;
    /**
     * Get/Set the effect.
     */
    effect: StyleEffectResult;
  }
  /**
   * The style modifier to clone or resume style when change its attributes.
   */
  class StyleModifier {}
  /**
   * The video texture what can play video stream and can be used by object's style.
   * @param param - The initial parameters.
   */
  class VideoTexture extends THING.BaseStaticTexture {
    constructor(param: any);
    /**
     * Copy from image.
     * @param source - The image.
     */
    copy(source: THING.VideoTexture): THING.VideoTexture;
    /**
     * Clone image.
     */
    clone(): THING.VideoTexture;
    /**
     * Get/Set url.
     */
    url: string;
    /**
     * Check class type.
     */
    isVideoTexture: boolean;
    /**
     * Get the color format.
     */
    colorFormat: number;
    /**
     * Get the anisotropy.
     */
    anisotropy: number;
    /**
     * Get the wrap type.
     */
    wrapType: ImageWrapType;
    /**
     * Get the mappingType type.
     */
    mappingType: ImageMappingType;
    /**
     * Get the min filter type.
     */
    minFilterType: ImageFilterType;
    /**
     * Get the mag filter type.
     */
    magFilterType: ImageFilterType;
    /**
     * Get flipY.
     */
    flipY: boolean;
    /**
     * Get premultiply alpha.
     */
    premultiplyAlpha: boolean;
    /**
     * Check generate mipmaps.
     */
    generateMipmaps: boolean;
    /**
     * Check class type.
     */
    isBaseStaticTexture: boolean;
  }
  /**
     * AsyncSelector
    The async selector.
     */
  class AsyncSelector {}
  /**
     * DynamicSelector
    The dynamic selector to find objects with some conditions.
     */
  class DynamicSelector {
    /**
         * Check class type.
         * @example
         * let object = new THING.Object3D();
        let selector = new THING.DynamicSelector(object, '*');
        // @expect(selector.isDynamicSelector == true);
         */
    isDynamicSelector: boolean;
  }
  /**
     * Selector
    The selector to find objects with some conditions.
     */
  class Selector {
    /**
         * Select objects by condition with object's queryable state.
         * @example
         * // Select entities from objects
        let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let entities = selector.select('.Entity', objects);
        let entity = entities[0];
        let ret = entity.isEntity;
        // @expect(ret == true)
         * @param condition - The conditions.
         * @param objects - The objects what to be queried.
         */
    select(condition: string, objects: object[]): object[];
    /**
         * Test the single object with some conditions (without object's queryable state).
         * @example
         * // Test whether object fit specified condition
        let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let object = new THING.Entity();
        let ret = selector.test('.Entity', object);
        // @expect(ret == true);
        let box = new THING.Box();
        ret = selector.test('.Entity', box);
        // @expect(ret == false);
         * @param condition - The conditions.
         * @param object - The object what to be queried.
         */
    test(condition: string, object: THING.BaseObject): boolean;
    /**
         * Find objects with some conditions and store it in result.
         * @example
         * // Query/select objects by specified condition
        let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let entitys = selector.query('.Entity');
        let entity = entitys[0];
        // @expect(entity.isEntity == true);
         * @param condition - The conditions.
         * @returns The reference of target or new selector.
         */
    query(condition: string): THING.Selector;
    /**
         * Query children by reg exp.
         * @example
         * let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let car = selector.queryByRegExp(/car/);
        let ret = car.length != 0;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    queryByRegExp(condition: string, options: any): THING.Selector;
    /**
         * Query children by tag.
         * @example
         * let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let car = selector.queryByTags('Entity')
        let ret = car.length != 0;
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    queryByTags(condition: string, options: any): THING.Selector;
    /**
         * Query children by name.
         * @example
         * let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let car = selector.queryByName('car1');
        let ret = car.length != 0 && car[0].name == 'car1';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    queryByName(condition: string, options: any): THING.Selector;
    /**
         * Query children by uuid.
         * @example
         * let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let car = selector.queryByUUID('1605');
        let ret = car.length != 0 && car[0].uuid == '1605';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    queryByUUID(condition: string, options: any): THING.Selector;
    /**
         * Query children by id.
         * @example
         * let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let car = selector.queryById('car01');
        let ret = car.length != 0 && car[0].id == 'car01';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    queryById(condition: string, options: any): THING.Selector;
    /**
         * Query children by type.
         * @example
         * let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let entitys = selector.queryByType('Entity');
        let ret = entitys.length != 0 && entitys[0].type == 'Entity';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    queryByType(condition: string, options: any): THING.Selector;
    /**
         * Query children by userData.
         * @example
         * let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let car = selector.queryByUserData('id="666"')
        let ret = car.length != 0 && car[0].userData.id == '666';
        // @expect(ret == true)
         * @param condition - The condition to select objects.
         * @param options - The options.
         */
    queryByUserData(condition: string, options: any): THING.Selector;
    /**
         * Find objects with some conditions and returns the first one.
         * @example
         * let objects = app.query('.BaseObject');
        let selector = new THING.Selector(objects);
        let entity = selector.find('.Entity')
        let ret = entity instanceof THING.Entity;;
        // @expect(ret == true)
         * @param condition - The conditions.
         * @param objects - The objects what to be queried.
         */
    find(condition: string, objects: object[]): BaseObject;
    /**
         * Push object into it.
         * @example
         * let objects = app.query('.Entity');
        let selector = new THING.Selector(objects);
        let count1 = selector.length;
        let object = new THING.BaseObject();
        let count2 = selector.push(object);
        let ret = count2 - count1 == 1;
        // @expect(ret == true)
         * @param object - The object what you want to push.
         * @returns The length of objects after push.
         */
    push(
      object: THING.BaseObject | THING.BaseObject[] | THING.Selector
    ): number;
    /**
         * Add objects by selector and return new one with results.
         * @example
         * let objects = app.query('.Entity');
        let selector = new THING.Selector(objects);
        let count1 = selector.length;
        let object1 = new THING.BaseObject();
        let object2 = new THING.BaseObject();
        selector.add([object1,object2]);
        let count2 = selector.length;
        let ret = count2 - count1 == 2;
        // @expect(ret == true)
         * @param selector - The selector or object(s) to add.
         */
    add(
      selector: THING.Selector | THING.BaseObject[] | THING.BaseObject
    ): THING.Selector;
    /**
         * Remove objects with some conditions and return new selector with results.
         * @example
         * let objects = app.query('.Entity');
        let selector = new THING.Selector(objects);
        selector.remove('.Entity');
        let count = selector.length;
        let ret = count == 0;
        // @expect(ret == true)
         * @param condition - The condition.
         */
    remove(condition: string): THING.Selector;
    /**
         * Clear objects.
         * @example
         * let objects = app.query('.Entity');
        let selector = new THING.Selector(objects);
        selector.clear();
        let ret = count == 0;
        // @expect(ret == true)
         */
    clear(): void;
    /**
         * Traverse objects.
         * @example
         * // Traverse all objects in selector
        selector.forEach((object) => {
            console.log(object);
        });
         * @param callback - The callback function(returns false indicates break it, otherwise continue to process it).
         */
    forEach(callback: OnTraverseObjectsInSelector): void;
    /**
         * Traverse objects in async mode.
         * @example
         * // Objects fly one by one(it would wait for previous object fly to complete before start)
        selector.forEachAsync(object => {
            return THING.App.current.camera.flyToAsync({
                target: object,
                duration: 1 * 1000,
                distance: 10,
                delayTime: THING.Math.randomFloat(0, 1000),
                complete: function (ev) {
                }
            });
        });
         * @param callback - The callback function(returns false indicates break it, otherwise continue to process it).
         */
    forEachAsync(callback: OnTraverseObjectsInSelector): void;
    /**
         * Traverse objects and return an new selector.
         * @example
         * // Returns all first child object of each objects
        let objects = selector.map((object) => {
            return object.children[0];
        });
         * @param callback - The callback function.
         */
    map(callback: OnMapObjectsInSelector): THING.Selector;
    /**
         * Executes a user-supplied "reducer" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element.
        The final result of running the reducer across all elements of the array is a single value.
         * @example
         * // Get avg height of entities
        let entities = app.query('.Entity');
        let height = entities.reduce((value, entity) => {
            return value + entity.position[1];
        }, 0) / entities.length;
         * @param callback - The callback function.
         * @param initialValue - The initial number.
         */
    reduce(callback: OnReduceObjectsInSelector, initialValue: number): number;
    /**
         * Return elements in range.
         * @example
         * // Returns [1, 4] range of objects
        let objects1 = selector.slice(1, 4);
        
        // Returns [1, ...] range of objects
        let objects2 = selector.slice(1);
         * @param start - The start index.
         * @param end? - The end index.
         */
    slice(start: number, end?: number): THING.Selector;
    /**
         * Filter.
         * @example
         * // Filter objects with name
        let objects = selector.filter((object) => {
            return !!object.name;
        });
         * @param callback - The callback function.
         */
    filter(callback: OnFilterObjectsInSelector): THING.Selector;
    /**
         * Sort objects from low to high by the result from callback function.
         * @example
         * // Sort objects by name
        selector.sort((obj1, obj2) => {
            return obj1.name.localeCompare(obj2.name);
        })
         * @param callback - The callback function to sort.
         */
    sort(callback: OnSortObjectsInSelector): THING.Selector;
    /**
         * Convert to array (Return a new array)
         * @example
         * // Get/Convert objects in array mode
        let objects = selector.objects;
        console.log(objects);
         */
    toArray(): THING.BaseObject[];
    /**
         * Check whether has/includes element.
         * @example
         * // Check whether includes specified object
        let exists = selector.includes(object);
         * @param object - The object.
         */
    includes(object: any): boolean;
    /**
         * Get the index of element in objects.
         * @example
         * // Get the index of object in selector
        let index = selector.indexOf(object);
         * @param object - The object.
         * @returns -1 indicates that specified object does not exist.
         */
    indexOf(object: any): number;
    /**
         * Remove objects.
         * @example
         * // Remove [1, 4] range of objects
        let removeObjects = selector.splice(1, 4);
         * @param index - The start index.
         * @param number - The number of objects what to remove.
         * @returns The removed objects.
         */
    splice(index: number, number: number): THING.Selector;
    /**
         * Insert object by index.
         * @example
         * // Insert objects at the front of selector
        selector.insert(0, [obj1, obj2]);
         * @param index - The index to insert.
         * @param object - The object to insert.
         */
    insert(index: number, object: THING.BaseObject): THING.Selector;
    /**
         * Remove object at index.
         * @example
         * // Remove the first object in selector.
        selector.remoteAt(0);
         * @param index - The index of object to remove.
         */
    removeAt(index: number): THING.Selector;
    /**
         * Swap objects by index.
         * @example
         * // Swap (index: 0) and (index:3) objects in selector
        selector.swap(0, 3);
         * @param index0 - The first index of objects.
         * @param index1 - The second index of objects.
         */
    swap(index0: number, index1: number): THING.Selector;
    /**
         * Combine array.
         * @example
         * // Concat other objects/selector and create new selector
        let newSelector = selector.concat([obj1, obj2]);
         * @param selector - The objects array or selector.
         */
    concat(selector: THING.Selector | THING.BaseObject[]): THING.Selector;
    /**
         * Reverse the objects.
         * @example
         * // Reverse objects in selector
        selector.reverse();
         */
    reverse(): THING.Selector;
    /**
         * Check whether has object or not.
         * @example
         * // Check whether has specified object
        let exists = selector.has(object);
         * @param object - The object.
         */
    has(object: any): boolean;
    /**
     * Check whether it's the same selector.
     * @example
     * let isSame = selector.equals([obj1, obj2]);
     * @param objects - The objects array or selector.
     */
    equals(objects: object[] | THING.Selector): boolean;
    /**
     * Get/Set the length of objects.
     * @example
     * let length = selector.length;
     */
    length: number;
    /**
         * Make objects in instanced drawing mode.
         * @example
         * // Enable objects instanced drawing
        selector.makeInstancedDrawing(true);
        
        // Disable objects instanced drawing
        selector.makeInstancedDrawing(false);
         * @param value - True indicates enable instanced drawing mode.
         * @param options - The options.
         */
    makeInstancedDrawing(value: boolean, options: any): void;
    /**
         * Get the instanced drawing objects.
         * @example
         * // Get the objects what has enabled instanced drawing
        let instancedDrawingObjects = selector.getInstancedDrawingObjects();
         */
    getInstancedDrawingObjects(): THING.BaseObject[];
    /**
         * Set visible state.
         * @example
         * // Set visible attribute of all objects in selector to true
        selector.setVisible(true);
        
        // Set visible attribute of all objects and its children in selector to true
        selector.setVisible(true, true);
         * @param value - True indicates show it, otherwise hide it.
         * @param [recursive = false] - True indicates process it with all children.
         */
    setVisible(value: boolean, recursive?: boolean): void;
    /**
         * Set all objects and its children visible state.
         * @example
         * // Set visible attribute of all objects and its children in selector to true
        selector.visible = true;
         */
    visible: boolean;
    /**
         * Set all objects and its children pickable state.
         * @example
         * // Set pickable attribute of all objects and its children in selector to true
        selector.pickable = true;
         */
    pickable: boolean;
    /**
         * Wait for all objects load completed.
         * @example
         * // Wait all objects load finished then print their name
        selector.waitForComplete().then((objects) => {
            objects.forEach(object => {
                console.log(object.name);
            });
        });
         */
    waitForComplete(): Promise<any>;
    /**
     * Destroy all.
     * @example
     * selector.destroy();
     */
    destroy(): void;
    /**
     * Load resource.
     * @example
     * selector.loadResource();
     * @param options - The load options.
     */
    loadResource(options: any): void;
    /**
     * Unload resource.
     * @example
     * selector.unloadResource();
     */
    unloadResource(): void;
    /**
         * Register all objects event.
         * @example
         * // Register all entities with 'click' event listener
        let mark = 0;
        let entity = new THING.Entity();
        entity.on('test', ()=>{
           mark = 1;
        })
        let selector = new THING.Selector([entity]);
        let markOn = 0;
        selector.on('testOn', function(ev) {
                markOn = 1;
        });
        selector.trigger('testOn');
        // @expect(markOn == 1 && mark == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first)
         * @param options - The options.
         */
    on(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Register all objects event what just trigger once time.
         * @example
         * // Register all entities with 'click' event listener in one time
        let mark = 0;
        let entity = new THING.Entity();
        entity.on('test', ()=>{
           mark = 1;
        })
        let selector = new THING.Selector([entity]);
        let markOnce = 0;
        selector.once('testOnce', function(ev) {
                markOnce = 1;
        });
        selector.trigger('testOnce');
        // @expect(markOnce == 1 && mark == 1);
        markOnce = 0;
        mark = 0;
        selector.trigger('testOnce');
        // @expect(markOnce == 0 && mark == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param callback - The callback function.
         * @param tag - The event tag.
         * @param priority - The priority value(default is 0, higher value will be processed first)
         * @param options - The options.
         */
    once(
      type: string,
      condition: string,
      callback: (...params: any[]) => any,
      tag: string,
      priority: number,
      options: ObjectEventOptions
    ): void;
    /**
         * Unregister all objects event.
         * @example
         * // Unregister all entities with 'click' event listener by tag name
        let mark = 0;
        let entity = new THING.Entity();
        entity.on('test', ()=>{
           mark = 1;
        })
        let selector = new THING.Selector([entity]);
        let markOff = 0;
        selector.on('testOff', function(ev) {
                markOff = 1;
        });
        selector.trigger('testOff');
        // @expect(markOff == 1 && mark == 1);
        markOff = 0;
        mark = 0;
        selector.off('testOff');
        selector.trigger('testOff');
        // @expect(markOff == 0 && mak == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    off(type: string, condition: string, tag: string): void;
    /**
         * Pause all objects event.
         * @example
         * // Pause all entities with 'click' event listener by tag name
        let mark = 0;
        let entity = new THING.Entity();
        entity.on('test', ()=>{
           mark = 1;
        })
        let selector = new THING.Selector([entity]);
        let markPause = 0;
        selector.on('testPause', function(ev) {
                markPause = 1;
        });
        selector.trigger('testPause');
        // @expect(markPause == 1 && mark == 1);
        markPause = 0;
        mark = 0;
        selector.PauseEvent('testPause');
        selector.trigger('testPause');
        // @expect(markPause == 0 && mark == 0);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    pauseEvent(type: string, condition: string, tag: string): void;
    /**
         * Resume all objects event.
         * @example
         * // Resume all entities with 'click' event listener by tag name
        let mark = 0;
        let entity = new THING.Entity();
        entity.on('test', ()=>{
           mark = 1;
        })
        let selector = new THING.Selector([entity]);
        let markResume = 0;
        selector.on('testPause', function(ev) {
                markResume = 1;
        });
        selector.trigger('testPause');
        // @expect(markResume == 1 && mark == 1);
        markResume = 0;
        mark = 0;
        selector.PauseEvent('testPause');
        selector.trigger('testPause');
        // @expect(markResume == 0 && mark == 0);
        selector.resumeEvent('testPause');
        selector.trigger('testPause');
        // @expect(markResume == 1 && mark == 1);
         * @param type - The event type.
         * @param condition - The condition to select objects.
         * @param tag - The event tag.
         */
    resumeEvent(type: string, condition: string, tag: string): void;
    /**
         * Trigger all objects event.
         * @example
         * // Trigger all entities with 'click' event listener by tag name
        let mark = 0;
        let entity = new THING.Entity();
        entity.on('test', ()=>{
          mark = 1;
        })
        let selector = new THING.Selector([entity]);
        selector.trigger('test');
        // @expect(mark == 1)
         * @param type - The event type.
         * @param ev - The event info.
         * @param options - The options.
         * @param options.tag - The tag name.
         */
    trigger(
      type: string,
      ev: any,
      options: {
        tag: string;
      }
    ): void;
    /**
         * Get the axis-aligned bounding box(AABB).
         * @example
         * let selector = new THING.Selector();
        let box = selector.getBoundingBox();
        let ret = box.size[0] == 0;
        // @expect(ret == true);
         */
    getBoundingBox(): THING.Box3;
    /**
         * Check class type.
         * @example
         * let selector = new THING.Selector();
        // @expect(selector.isSelector == true);
         */
    isSelector: boolean;
  }
}

/**
 * The action message data.
 * @property type - The action type.
 * @property target - The target to filer object what to process this action, if not provide then indicates use app's root as target object.
 * @property params - The parameters what pass to action.
 * @property delay - The delay to start performing the current action.
 * @property waitForComplete - Wait for the current action to complete before executing the next action, The default is false.
 */
declare type ActionMessageData = {
  type: string;
  target: string;
  params: any;
  delay: number;
  waitForComplete: boolean;
};

/**
 * @property minFilter - The min filter type.
 * @property magFilter - The mag filter type.
 * @property wrapS - The horz wrap type.
 * @property wrapT - The vert wrap type.
 */
declare type LoadTextureResourceSamplerInfo = {
  minFilter: ImageFilterType;
  magFilter: ImageFilterType;
  wrapS: ImageWrapType;
  wrapT: ImageWrapType;
};

/**
 * When create texture.
 * @param url - The url.
 * @param sampler - The sampler info.
 */
declare type onCreateTextureCallback = (
  url: string,
  sampler: LoadTextureResourceSamplerInfo
) => THING.BaseTexture;

/**
 * When create texture in async mode.
 * @param url - The url.
 * @param sampler - The sampler info.
 */
declare type onCreateTextureAsyncCallback = (
  url: string,
  sampler: LoadTextureResourceSamplerInfo
) => Promise<any>;

/**
 * The function to call when level changed.
 * @param ev - The event info.
 * @param ev.current - The current level.
 * @param ev.prev - The previous level.
 * @param ev.path - The path from start to target object.
 */
declare type LevelChangedCallback = (ev: {
  current: THING.BaseObject;
  prev: THING.BaseObject;
  path: THING.BaseObject[];
}) => void;

/**
 * @param onStop - The callback function would be trigged when stop level change.
 * @param onComplete - The callback function would be trigged when complete level change.
 */
declare type LevelChangeOptions = any;

/**
 * @param priority - The level control priority. The default value is 0. A smaller value is executed first.
 * @param tag - The level control tag.
 */
declare type RegisterControlOptions = any;

/**
 * The function to call when start to get object level path.
 * @param path - The level path.
 */
declare type FilterLevelPathCallback = (
  path: THING.BaseObject[]
) => THING.BaseObject[];

/**
 * @property start - The start function.
 * @property stop - The stop function.
 * @property times - The repeat times setting function.
 * @property easing - The lerp setting function.
 * @property looping - The looping setting function.
 * @property onRepeat - When repeat callback function.
 * @property onStart - When start callback function.
 * @property onStop - When start callback function.
 * @property onUpdate - When update callback function.
 * @property onComplete - When complete callback function.
 */
declare type LerpToResult = {
  start: (...params: any[]) => any;
  stop: (...params: any[]) => any;
  times: (...params: any[]) => any;
  easing: (...params: any[]) => any;
  looping: (...params: any[]) => any;
  onRepeat: (...params: any[]) => any;
  onStart: (...params: any[]) => any;
  onStop: (...params: any[]) => any;
  onUpdate: (...params: any[]) => any;
  onComplete: (...params: any[]) => any;
};

/**
 * @property name - The animation name.
 * @property times? - The loop times.
 * @property loopType? - The loop type.
 * @property [speed = 1] - The playing speed.
 * @property [reverse = false] - True indicates to play in reverse mode.
 * @property [onComplete = null] - The callback function to receive complete event.
 */
declare type PlayAnimationArgs = {
  name: string;
  times?: number;
  loopType?: LoopType;
  speed?: number;
  reverse?: boolean;
  onComplete?: (...params: any[]) => any;
};

/**
 * @property name - The name.
 * @property duration - The duration in seconds.
 * @property speed - The playing speed.
 * @property state - The state type.
 */
declare type AnimationResult = {
  name: string;
  duration: number;
  speed: number;
  state: PlayStateType;
};

/**
 * @property [name = ''] - The name.
 * @property [id = ''] - The id.
 */
declare type BaseObjectInitialOptions = {
  name?: string;
  id?: string;
};

/**
 * @property type - The event type.
 * @property condition - The condition to select objects.
 * @property callback - The event callback.
 * @property tag - The event tag.
 * @property priority - The event priority.
 * @property once - True indicates it's trigger only once event.
 * @property paused - True indicates it had paused.
 */
declare type ObjectListenerInfo = {
  type: string;
  condition: string;
  callback: (...params: any[]) => any;
  tag: string;
  priority: number;
  once: boolean;
  paused: boolean;
};

/**
 * @property useCapture - True indicates capture all same events from children.
 */
declare type ObjectEventOptions = {
  useCapture: boolean;
};

/**
 * @property recursive - True indicates query in recursive mode.
 * @property includeSelf - True indicates including self.
 */
declare type ObjectQueryOptions = {
  recursive: boolean;
  includeSelf: boolean;
};

/**
 * @property width - The width.
 * @property height - The height.
 * @property near - The near.
 * @property far - The far.
 */
declare type ShadowRangeInfo = {
  width: number;
  height: number;
  near: number;
  far: number;
};

/**
 * @property center - The center of box.
 * @property halfSize - The half size of box.
 */
declare type BoundingBoxResult = {
  center: Number[];
  halfSize: Number[];
};

/**
 * @property direction - The direction in world space.
 * @property height - The height.
 */
declare type ClippingPlaneResult = {
  direction: Number[];
  height: number;
};

/**
 * @property getBlueprintClasses - Get the blueprint classes.
 * @property getExportProperties - Get the export properties.
 * @property getExportFunctions - Get the export functions.
 */
declare type PrefabEntrance = {
  getBlueprintClasses: (...params: any[]) => any;
  getExportProperties: (...params: any[]) => any;
  getExportFunctions: (...params: any[]) => any;
};

/**
 * The lensflare element.
 * @property imageTexture - The element image texture resource.
 * @property color - The element color.
 * @property scale - The element scale.
 * @property offset - The element offset.
 */
declare type LensflareElement = {
  imageTexture: ImageTexture;
  color: Number[];
  scale: number;
  offset: number;
};

/**
 * @property object - The object.
 * @property image - The image.
 */
declare type FitBodyScaleInfo = {
  object: THING.Marker;
  image: any;
};

/**
 * The function to call when fit body scale.
 * @param info - The info.
 */
declare type OnFitBodyScaleCallback = (info: FitBodyScaleInfo) => void;

/**
 * @property localPosition? - The local position.
 * @property localScale? - The local scale.
 * @property localAngels? - The local angles.
 * @property position? - The world position.
 * @property scale? - The world scale.
 * @property angels? - The world angles.
 */
declare type Object3DInitialOptions = BaseObjectInitialOptions;

/**
 * The function to call when start to process some action with object(s).
 * @param object - The object.
 */
declare type ProcessObjectCallback = (object: Object3D) => boolean;

/**
 * @property visible? - The visible attributes inherit type (default value is InheritType.Normal).
 * @property pickable? - The visible attributes inherit type (default value is InheritType.Normal).
 */
declare type InheritData = {
  visible?: InheritType;
  pickable?: InheritType;
};

/**
 * @property origin - The start position.
 * @property direction - The direction in world space.
 */
declare type RaycastInfo = {
  origin: Number[];
  direction: Number[];
};

/**
 * @property object - The picked object.
 * @property position - The picked position.
 * @property distance - The distance to ray origin.
 */
declare type RaycastResult = {
  object: THING.Object3D;
  position: Number[];
  distance: number;
};

/**
 * @property url - The url.
 * @property localPosition? - The local position.
 * @property localAngles? - The local angles.
 * @property localScale? - The local scale.
 * @property children? - The children.
 */
declare type ResourceResult = {
  url: string;
  localPosition?: Number[];
  localAngles?: Number[];
  localScale?: Number[];
  children?: ResourceResult[];
};

/**
 * @property vertices - The number of vertices.
 * @property triangles - The number of triangles.
 * @property materials - The number of materials.
 * @property textures - The number of textures.
 */
declare type RenderableNodeGeometryInfo = {
  vertices: number;
  triangles: number;
  materials: number;
  textures: number;
};

/**
 * @property angles - The angles base on center.
 * @property center - The center world position.
 * @property size - The bounding box size.
 * @property halfSize - The bounding box half size.
 * @property radius - The bounding box radius.
 */
declare type OrientedBoxResult = {
  angles: Number[];
  center: Number[];
  size: Number[];
  halfSize: Number[];
  radius: number;
};

/**
 * @property from - The source attributes.
 * @property to - The target attributes.
 * @property [loop = -1] - The loop times, -1 indicates unlimited, and set the loop type to repeat.
 * @property [times = -1] - The loop times, -1 indicates unlimited.
 * @property [duration = 1000] - The time in milliseconds.
 * @property [delayTime = 0] - The delay time in milliseconds.
 * @property lerpType? - The lerp type.
 * @property loopType? - The loop type.
 * @property orientToPath? - Whether to face the path when moving.
 * @property onRepeat - The callback function to trigger repeat action.
 * @property onStart - The callback function to trigger start action.
 * @property onStop - The callback function to trigger stop action.
 * @property onUpdate - The callback function to trigger update action.
 * @property onComplete - The callback function to trigger complete action.
 */
declare type LerpArgs = {
  from: any;
  to: any;
  loop?: number;
  times?: number;
  duration?: number;
  delayTime?: number;
  lerpType?: LerpType;
  loopType?: LoopType;
  orientToPath?: boolean;
  onRepeat: (...params: any[]) => any;
  onStart: (...params: any[]) => any;
  onStop: (...params: any[]) => any;
  onUpdate: (...params: any[]) => any;
  onComplete: (...params: any[]) => any;
};

/**
 * The position/rotate/scale lerp args.
 * @param [spaceType = THING.SpaceType.World] - The space type.
 */
declare type LerpWithSpaceTypeArgs = LerpArgs;

/**
 * @param up - The up direction.
 * @param [closure = false] - True indicates it's closure path.
 */
declare type MovePathLerpArgs = LerpWithSpaceTypeArgs;

/**
 * @property position - The position where to fly.
 * @property target - The target where to fly, if it's object then auto select the best position from its bounding box.
 * @property duration - The action time in milliseconds.
 * @property delayTime - The delay time in milliseconds.
 * @property distance - The distance(only works for object target mode).
 * @property horzAngle - The horz angle(only works for object target mode).
 * @property vertAngle - The vert angle(only works for object target mode).
 * @property lerpType - The lerp type.
 * @property positionLerpType - The position lerp type.
 * @property targetLerpType - The target lerp type.
 * @property upLerpType - The lerp type.
 * @property onStart - The start callback function.
 * @property onStop - The stop callback function.
 * @property onUpdate - The update callback function.
 * @property onComplete - The complete callback function.
 */
declare type LerpFlyToArgs = {
  position?: Number[];
  target?: Number[] | THING.BaseObject;
  duration?: number;
  delayTime?: number;
  distance?: number;
  horzAngle?: number;
  vertAngle?: number;
  lerpType?: LerpType;
  positionLerpType?: LerpType;
  targetLerpType?: LerpType;
  upLerpType?: LerpType;
  onStart?: (...params: any[]) => any;
  onStop?: (...params: any[]) => any;
  onUpdate?: (...params: any[]) => any;
  onComplete?: (...params: any[]) => any;
};

/**
 * @property up - The up direction.
 * @property [lockAxis] - The lock axis type.
 * @property [always = false] - True indicates look at target always
 * @property [lookOnPlane = false] - True indicates look on target's plane by its forward.
 */
declare type LookAtArgs = {
  up: Number[];
  lockAxis?: AxisType;
  always?: boolean;
  lookOnPlane?: boolean;
};

/**
 * The particle's maximum age attribute.
 * @property value - A number describing the amount of maxAge to apply to all particles.
 * @property spread - A number describing the maxAge variance on a per-particle basis.
 */
declare type MaxAge = {
  value: number;
  spread: number;
};

/**
 * The emitter's position attribute.
 * @property value - An array describing this emitter's base position.
 * @property spread - An array describing this emitter's position variance on a per-particle basis.
 * @property spreadClamp - An array describing the numeric multiples the particle's should be spread out over.
 * @property radius - This emitter's base radius.
 * @property radiusScale - An array describing the radius's scale in all three axes.
 * @property distribution - A specific distribution to use when radiusing particles. Overrides the `ParticleEmitterAttributeType.Distribution` option.
 * @property randomise - When a particle is re-spawned, whether it's position should be re-randomised or not.
 */
declare type Position = {
  value: Number[];
  spread: Number[];
  spreadClamp: Number[];
  radius: number;
  radiusScale: Number[];
  distribution: number;
  randomise: boolean;
};

/**
 * The emitter's rotation attribute.
 * @property axis - An array describing this emitter's axis of rotation.
 * @property axisSpread - An array describing the amount of variance to apply to the axis of rotation on a per-particle basis.
 * @property angle - The angle of rotation, given in radians. If `Rotation.static` is true, the emitter will start off rotated at this angle, and stay as such.
                         Otherwise, the particles will rotate from 0radians to this value over their lifetimes.
 * @property angleSpread - The amount of variance in each particle's rotation angle.
 * @property static - Whether the rotation should be static or not.
 * @property center - An array describing the center point of rotation.
 * @property randomise - When a particle is re-spawned, whether it's rotation should be re-randomised or not.
 */
declare type Rotation = {
  axis: Number[];
  axisSpread: Number[];
  angle: number;
  angleSpread: number;
  static: boolean;
  center: Number[];
  randomise: boolean;
};

/**
 * The emitter's velocity attribute.
 * @property value - An array describing this emitter's base velocity.
 * @property spread - An array describing this emitter's velocity variance on a per-particle basis.
 * @property distribution - A specific distribution to use when calculating a particle's velocity. Overrides the `ParticleEmitterAttributeType.Distribution` option.
 * @property randomise - When a particle is re-spawned, whether it's velocity should be re-randomised or not.
 */
declare type Velocity = {
  value: Number[];
  spread: Number[];
  distribution: number;
  randomise: boolean;
};

/**
 * The emitter's color attribute.
 * @property value - Either an array, or multiple arrays to describe the color of a particle over it's lifetime.
 * @property spread - Either an array, or multiple arrays to describe the color variance of a particle over it's lifetime.
 * @property randomise - When a particle is re-spawned, whether it's color should be re-randomised or not.
 */
declare type ListColor = {
  value: Number[];
  spread: Number[];
  randomise: boolean;
};

/**
 * The emitter's opacity attribute.
 * @property value - Either a number, or an array of numbers to describe the opacity of a particle over it's lifetime.
 * @property spread - Either a number, or an array of numbers to describe the opacity variance of a particle over it's lifetime.
 * @property randomise - When a particle is re-spawned, whether it's opacity should be re-randomised or not.
 */
declare type ListOpacity = {
  value: number;
  spread: number;
  randomise: boolean;
};

/**
 * The emitter's size attribute.
 * @property value - Either a number, or an array of numbers to describe the size of a particle over it's lifetime.
 * @property spread - Either a number, or an array of numbers to describe the size variance of a particle over it's lifetime.
 * @property randomise - When a particle is re-spawned, whether it's size should be re-randomised or not.
 */
declare type ListSize = {
  value: number;
  spread: number;
  randomise: boolean;
};

/**
 * The emitter's angle attribute.
 * @property value - Either a number, or an array of numbers to describe the angle of a particle over it's lifetime.
 * @property spread - Either a number, or an array of numbers to describe the angle variance of a particle over it's lifetime.
 * @property randomise - When a particle is re-spawned, whether it's angle should be re-randomised or not.
 */
declare type ListAngle = {
  value: number;
  spread: number;
  randomise: boolean;
};

/**
 * The emitter's acceleration attribute.
 * @property value - An array describing this emitter's base acceleration.
 * @property spread - An array describing this emitter's acceleration variance on a per-particle basis.
 * @property distribution - A specific distribution to use when calculating a particle's acceleration. Overrides the `ParticleEmitterAttributeType.Distribution` option.
 * @property randomise - When a particle is re-spawned, whether it's acceleration should be re-randomised or not.
 */
declare type Acceleration = {
  value: Number[];
  spread: Number[];
  distribution: number;
  randomise: boolean;
};

/**
 * The emitter's drag attribute.
 * @property value - A number between 0 and 1 describing the amount of drag to apply to all particles.
 * @property spread - A number describing the drag variance on a per-particle basis.
 * @property randomise - When a particle is re-spawned, whether it's drag should be re-randomised or not.
 */
declare type Drag = {
  value: number;
  spread: number;
  randomise: boolean;
};

/**
 * The texture's animation attribute.
 * @property frames - The number of frames on the x- and y-axis of the given texture.
 * @property frameCount - The total number of frames in the sprite-sheet.
 * @property loop - The number of loops through the sprite-sheet that should be performed over the course of a single particle's lifetime.
 */
declare type TextureAnimation = {
  frames: Number[];
  frameCount: number;
  loop: number;
};

/**
 * The pixel buffer with size.
 * @property data - The pixel buffer data.
 * @property width - The buffer width.
 * @property height - The buffer height.
 */
declare type PixelBuffer = {
  data: any;
  width: number;
  height: number;
};

/**
 * The pixel buffer with size.
 * @property resource - The pixel buffer data.
 */
declare type CanvasResource = {
  resource: HTMLElement;
};

/**
 * @property enable - True indicates enable it.
 * @property color - The color.
 * @property opacity - The opacity.
 * @property glow - True indicates enable glow effect.
 */
declare type StyleEdgeResult = {
  enable: boolean;
  color: Number[];
  opacity: number;
  glow: boolean;
};

/**
 * @property glow - The glow intensity (null indicates resume original effect).
 * @property innerGlow - The inner glow effect (null indicates resume original effect).
 * @property lineBloom - The line bloom effect (null indicates resume original effect).
 * @property tailing - The tailing effect (null indicates resume original effect).
 * @property radial - The radial effect (null indicates resume original effect).
 * @property ghosting - The ghosting effect (null indicates resume original effect).
 */
declare type StyleEffectResult = {
  glow: number;
  innerGlow: boolean;
  lineBloom: boolean;
  tailing: boolean;
  radial: boolean;
  ghosting: boolean;
};

declare type StyleImagesResult = {
  map: any;
  envMap: any;
  alphaMap: any;
  emissiveMap: any;
  normalMap: any;
  colorMapping: any;
  aoMap: any;
};

/**
 * @property offset - The offset of UV matrix, default: [0, 0]
 * @property repeat - The repeat of UV matrix, default: [1, 1]
 * @property center - The center of UV matrix, default: [0, 0]
 * @property rotation - The rotation in degree.
 */
declare type StyleUVMatrixResult = {
  offset: Number[];
  repeat: Number[];
  center: Number[];
  rotation: number;
};

/**
 * The function to call when update value.
 * @param baseValue - The base value.
 * @param style - The style.
 */
declare type StyleValueOperationCallback = (
  baseValue: number,
  style: THING.Style
) => void;

/**
 * The function to call when update color.
 * @param baseValue - The base color.
 * @param style - The style.
 */
declare type StyleColorOperationCallback = (
  baseValue: Number[],
  style: THING.Style
) => void;

/**
 * The function to call when to get objects by forEach.
 * @param object - The object.
 * @param index - The index of objects.
 * @param objects - The objects.
 */
declare type OnTraverseObjectsInSelector = (
  object: THING.BaseObject,
  index: number,
  objects: THING.BaseObject[]
) => void;

/**
 * The function to call when to get objects by map.
 * @param object - The object.
 * @param index - The index of objects.
 * @param objects - The objects.
 */
declare type OnMapObjectsInSelector = (
  object: THING.BaseObject,
  index: number,
  objects: THING.BaseObject[]
) => THING.BaseObject;

/**
 * The function to call when to reduce in selector.
 * @param accumulator - The accumulate value.
 * @param currentValue - The current value.
 * @param currentIndex - The current index.
 * @param objects - The objects.
 */
declare type OnReduceObjectsInSelector = (
  accumulator: number,
  currentValue: number,
  currentIndex: number,
  objects: THING.BaseObject[]
) => number;

/**
 * The function to call when to get objects by filter.
 * @param object - The object.
 * @param index - The index of objects.
 * @param objects - The objects.
 */
declare type OnFilterObjectsInSelector = (
  object: THING.BaseObject,
  index: number,
  objects: THING.BaseObject[]
) => boolean;

/**
 * The function to call when to sort objects.
 * @param obj1 - The first object.
 * @param obj2 - The second object.
 */
declare type OnSortObjectsInSelector = (
  obj1: THING.BaseObject,
  obj2: THING.BaseObject
) => number;
